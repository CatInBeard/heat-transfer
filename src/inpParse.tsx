class InpParsingError extends Error {
    constructor(message: string = "Parsing .inp error") {
        super(message);
        this.name = 'InpParsingError';
    }
}

type partProblem = {
    name: string,
    nodes: Array<Array<number>>,
    elements: Array<Array<number>>,
    nsets: Array<Nset>,
    lsets: Array<Lset>,
    sections: Array<Section>
}

type Nset = {
    setname: string
    nodes: Array<number>
}

type Lset = {
    setname: string
    nodes: Array<number>
}

type Section = {
    name: string,
    type: string,
    elsetName: string,
    material: string
}

type Material = {
    name: string,
    conductivity: number,
    density: number,
    specificHeat: number
}

type Step = {
    name: string,
    jobType: string,
    stateType: string
    boundaries: {
        temperature: Array<TemperatureBC>
    } ,
}

type TemperatureBC = {
    name: string,
    type: string,
    setName: string,
    temperature: number
}

function range(start: number, end: number, step: number = 1): Array<number> {
    let result: number[] = [];
    for (let i = start; i <= end; i += step) {
        result.push(i);
    }
    return result;
}

const parseInpText = (inpTextData: string) => {

    let inpDataLines: Array<string> = clearCR(inpTextData).split("\n");

    let inpData = [];
    inpData["heading"] = getHeadings(inpDataLines);
    inpData["problemData"] = getProblemData(inpDataLines);
    inpData["materials"] = getMaterialsData(inpDataLines);
    inpData["steps"] = getStepData(inpDataLines);

    return inpData;
}

const clearCR = (text: string): string => {
    return text.replace(/\r/g, "");
}

const getHeadings = (inpDataLines: Array<string>) => {

    checkHeading(inpDataLines);

    const lines = findHeadingLines(inpDataLines);
    const { jobName, modelName } = getJobAndModelName(inpDataLines, lines.jobNameLine);
    const generatedBy = getGeneratedBy(inpDataLines, lines.generatedByLine);

    return { jobName: jobName, modelName: modelName, generatedBy: generatedBy }
}

const checkHeading = (inpDataLines: Array<string>) => {
    if (!inpDataLines[0].startsWith("*Heading")) {
        throw new InpParsingError("Heading is not defined");
    }
}

const findHeadingLines = (inpDataLines: Array<string>) => {
    let inpDataLinesCount: number = inpDataLines.length;
    let jobNameLine: number = 0;
    let generatedByLine: number = 0;

    for (let i = 0; i < inpDataLinesCount; i++) {
        if (inpDataLines[i].startsWith("** Job name:")) {
            jobNameLine = i;
        }
        if (inpDataLines[i].startsWith("** Generated by:")) {
            generatedByLine = i;
        }

        if (jobNameLine != 0 && generatedByLine != 0) {
            break;
        }
    }

    if (jobNameLine == 0 || generatedByLine == 0) {
        throw new InpParsingError("Heading parsing error");
    }

    return { jobNameLine: jobNameLine, generatedByLine: generatedByLine }
}

const getJobAndModelName = (inpDataLines: Array<string>, jobNameLine: number) => {

    const regex: RegExp = /Job name: (.*?) Model name: (.*?)$/;
    const matches: RegExpMatchArray | null = inpDataLines[jobNameLine].match(regex);

    if (matches && matches.length === 3) {
        var jobName: string = matches[1];
        var modelName: string = matches[2];
    } else {
        throw new InpParsingError("Job name or model name not found!");
    }
    return { jobName: jobName, modelName: modelName }
}

const getGeneratedBy = (inpDataLines: Array<string>, generatedByLine: number) => {
    const regexGenBy: RegExp = /Generated by: (.*?)$/;

    const match: RegExpMatchArray | null = inpDataLines[generatedByLine].match(regexGenBy);

    if (match && match.length === 2) {
        var generatedBy = match[1];
    } else {
        throw new InpParsingError("Generated by not found");
    }
    return generatedBy;
}

const getProblemData = (inpDataLines: Array<string>): Array<partProblem> => {

    const parts = findParts(inpDataLines);

    let partsProblems: Array<partProblem> = [];

    for (let i: number = 0; i < parts.length; i++) {
        partsProblems.push(parsePartLines(parts[i]));
    }



    return partsProblems
}

const parsePartLines = (part: Array<string>): partProblem => {


    const regexGenBy: RegExp = /Part, name=(.*?)$/;

    const match: RegExpMatchArray | null = part[0].match(regexGenBy);

    if (match && match.length === 2) {
        var partName = match[1];
    } else {
        throw new InpParsingError("Part name not found");
    }

    let nodes: Array<Array<number>> = []
    let elements: Array<Array<number>> = []
    let nsets: Array<Nset> = []
    let lsets: Array<Lset> = []
    let sections: Array<Section> = []

    let nodeParsingFlag: boolean = false;
    let elementParsingFlag: boolean = false;
    let nsetFlag: boolean = false;
    let lsetFlag: boolean = false;
    let sectionFlag: boolean = false;


    for (let i = 1; i < part.length; i++) {
        if (sectionFlag) {
            const regex: RegExp = /\*(\w+) Section.*elset=([^\s,]+).*material=([^\s,]+)/;
            const result: RegExpMatchArray | null = part[i].match(regex);

            if (result && result.length === 4) {
                var [, sectionType, elsetName, material]: string[] = result;
            } else {
                throw new InpParsingError("Section data not found");
            }


            sections[sections.length - 1].elsetName = elsetName
            sections[sections.length - 1].material = material
            sections[sections.length - 1].type = sectionType

            sectionFlag = false
        }

        if (part[i].startsWith("*")) {
            nodeParsingFlag = false;
            elementParsingFlag = false;
            nsetFlag = false;
            lsetFlag = false;
            sectionFlag = false;
        }
        if (part[i].startsWith("*Node")) {
            nodeParsingFlag = true;
            continue;
        }
        if (part[i].startsWith("*Element")) {
            elementParsingFlag = true;
            continue;
        }
        if (part[i].startsWith("** Section:")) {
            sectionFlag = true;

            const regexGenBy: RegExp = /\*\* Section: (.*?)$/;
            const match: RegExpMatchArray | null = part[i].match(regexGenBy);
            if (match && match.length === 2) {
                var name = match[1];
            } else {
                throw new InpParsingError("Section name not found");
            }
            sections.push({ name: name, elsetName: "", material: "", type: "" });
            continue;
        }
        if (part[i].startsWith("*Nset")) {
            nsetFlag = true;

            const regexGenBy: RegExp = /nset=(.*?),/;
            const match: RegExpMatchArray | null = part[i].match(regexGenBy);
            if (match && match.length === 2) {
                var name = match[1];
            } else {
                throw new InpParsingError("Set name not found");
            }
            nsets.push({ setname: name, nodes: [] });
            continue;
        }
        if (part[i].startsWith("*Elset")) {
            lsetFlag = true;

            const regexGenBy: RegExp = /elset=(.*?),/;
            const match: RegExpMatchArray | null = part[i].match(regexGenBy);
            if (match && match.length === 2) {
                var name = match[1];
            } else {
                throw new InpParsingError("Set name not found");
            }
            lsets.push({ setname: name, nodes: [] });
            continue;
        }
        if (nodeParsingFlag) {
            nodes.push(part[i].split(',').map(num => parseFloat(num.trim())));
            continue;
        }
        if (elementParsingFlag) {
            elements.push(part[i].split(',').map(num => parseFloat(num.trim())));
            continue;
        }
        if (nsetFlag) {
            let setNodes = part[i].split(',').map(num => parseFloat(num.trim()))
            if (setNodes.length == 3 && part[i - 1].startsWith("*Nset")) {
                nsets[nsets.length - 1].nodes = range(setNodes[0], setNodes[1], setNodes[2]);
            }
            else {
                nsets[nsets.length - 1].nodes = [...nsets[nsets.length - 1].nodes, ...setNodes];
            }
        }
        if (lsetFlag) {
            let setElements = part[i].split(',').map(num => parseFloat(num.trim()))
            if (setElements.length == 3 && part[i - 1].startsWith("*Elset")) {
                lsets[lsets.length - 1].nodes = range(setElements[0], setElements[1], setElements[2]);
            }
            else {
                lsets[lsets.length - 1].nodes = [...lsets[lsets.length - 1].nodes, ...setElements];
            }
        }


    }


    return { name: partName, nodes: nodes, elements: elements, nsets: nsets, lsets: lsets, sections: sections };
}

const findParts = (inpDataLines: Array<string>): Array<Array<string>> => {

    let parts: Array<Array<string>> = [];

    let inpDataLinesCount: number = inpDataLines.length;

    let partsStart: number = inpDataLines.findIndex((line: string) => {
        return line.startsWith("** PARTS");
    });

    if (partsStart == -1) {
        throw new InpParsingError("PARTS section not found");
    }

    let currentPart: number = 0;

    for (let i = partsStart; i < inpDataLinesCount; i++) {
        let line: string = inpDataLines[i];
        if (line.startsWith("*Part")) {
            parts.push([line])
            continue
        }
        if (line.startsWith("*End Part")) {
            currentPart++;
            continue
        }

        if (parts.length > currentPart)
            parts[currentPart].push(line);

    }

    return parts;

}

const getMaterialStrings = (inpDataLines: Array<string>): Array<string> => {
    let strings: Array<string> = [];

    let materialSection: boolean = false;

    for (let i: number = 0; i < inpDataLines.length; i++) {
        if (inpDataLines[i].startsWith("** MATERIALS")) {
            materialSection = true;
            continue
        }

        if (inpDataLines[i].startsWith("** ---------")) {
            break;
        }

        if (materialSection) {
            strings.push(inpDataLines[i])
        }
    }

    return strings;
}

const getMaterialsData = (inpDataLines: Array<string>): Array<Material> => {

    let materials: Array<Material> = []

    let materialStrings: Array<string> = getMaterialStrings(inpDataLines);

    for (let i: number = 0; i < materialStrings.length; i++) {
        if (materialStrings[i].startsWith("*Material")) {
            const regexGenBy: RegExp = /name=(.*?)$/;
            const match: RegExpMatchArray | null = materialStrings[i].match(regexGenBy);
            if (match && match.length === 2) {
                materials.push({ name: match[1], conductivity: -1, density: -1, specificHeat: -1 })
            } else {
                throw new InpParsingError("Material name not found");
            }
            continue;
        }

        if (materialStrings[i].startsWith("**"))
            continue

        if (materialStrings[i - 1].startsWith("*Conductivity")) {
            materials[materials.length - 1].conductivity = parseFloat(materialStrings[i].trim());
        }
        if (materialStrings[i - 1].startsWith("*Density")) {
            materials[materials.length - 1].density = parseFloat(materialStrings[i].trim());
        }
        if (materialStrings[i - 1].startsWith("*Specific Heat")) {
            materials[materials.length - 1].specificHeat = parseFloat(materialStrings[i].trim());
        }
    }

    if (materials.length < 1) {
        throw new InpParsingError("At least one material must be specified");
    }

    for (let i: number = 0; i < materials.length; i++) {
        if (materials[i].conductivity < 0 || materials[i].density < 0 || materials[i].specificHeat < 0) {
            throw new InpParsingError("Material must have conductivity, density and specific heat parametrs");
        }
    }

    return materials;
}

const getStepStrings = (inpDataLines: Array<string>): Array<string> => {
    let strings: Array<string> = [];

    let stepSection: boolean = false;

    for (let i: number = 0; i < inpDataLines.length; i++) {
        if (inpDataLines[i].startsWith("** STEP:")) {
            stepSection = true;
            continue
        }

        if (stepSection) {
            strings.push(inpDataLines[i])
        }
    }

    return strings;
}

const getStepData = (inpDataLines: Array<string>): Array<Step> => {
    let steps: Array<Step> = []

    let stepStrings: Array<string> = getStepStrings(inpDataLines);

    let stepDataFlag: boolean = false;
    let boundarySectionFlag: boolean = false;

    for (let i: number = 0; i < stepStrings.length; i++) {
        if (stepStrings[i].startsWith("*Step, name=")) {
            stepDataFlag = true;
            boundarySectionFlag = false;

            const regexGenBy: RegExp = /name=(.*?),/;
            const match: RegExpMatchArray | null = stepStrings[i].match(regexGenBy);
            if (match && match.length === 2) {
                steps.push({
                    name: match[1],
                    stateType: "",
                    jobType: "",
                    boundaries: {temperature: []},
                })
            } else {
                throw new InpParsingError("Job name not found");
            }
            continue;
        }
        if (stepDataFlag) {
            const regex: RegExp = /\*(.*?), (.*?)$/;
            const matches: RegExpMatchArray | null = stepStrings[i].match(regex);

            if (matches && matches.length === 3) {
                steps[steps.length - 1].jobType = matches[1];
                steps[steps.length - 1].stateType = matches[2];
            } else {
                throw new InpParsingError("Step type or state type not found!");
            }
            stepDataFlag = false;
            continue;
        }

        if (stepStrings[i].startsWith("** BOUNDARY CONDITIONS")) {
            boundarySectionFlag = true;
            continue;
        }

        if (boundarySectionFlag) {

            if (stepStrings[i].startsWith("*Boundary")) {
                const regex: RegExp = /Name: (.*?) Type: (.*?)$/;
                const matches: RegExpMatchArray | null = stepStrings[i - 1].match(regex);

                let type =  '';

                if (matches && matches.length === 3) {

                    type = matches[2];

                    switch(type){
                        case "Temperature":
                        steps[steps.length - 1].boundaries.temperature.push({
                            name: matches[1],
                            type: matches[2],
                            setName: "",
                            temperature: 0
                        })
                        break;
                        default:
                            throw new InpParsingError("Unknown BC type!");
                    }

                } else {
                    throw new InpParsingError("Boundary name or type not found!");
                }

                if (!(i + 1 < stepStrings.length)) {
                    throw new InpParsingError("Boundary set name not found!");
                }


                switch(type){
                    case "Temperature":
                    
                    
                    let BCdata = stepStrings[i + 1].split(',').map(num => num.trim())

                    steps[steps.length - 1].boundaries.temperature[steps[steps.length - 1].boundaries.temperature.length - 1].setName = BCdata[0]

                    steps[steps.length - 1].boundaries.temperature[steps[steps.length - 1].boundaries.temperature.length - 1].temperature = parseFloat(BCdata[BCdata.length - 1])
                break;
                    default:
                        throw new InpParsingError("Unknown BC type!");
                }

            }



        }

    }

    return steps;
}

const checkInpDataForHeatTransfer = (inpDataLines) => {

    let steps: Array<Step> = inpDataLines.steps;

    for (let i = 0; i < steps.length; i++) {
        let step: Step = steps[i];

        if(step.jobType != "Heat Transfer"){
            throw new InpParsingError("The problem is not thermal");
        }
    }
}

export { parseInpText, checkInpDataForHeatTransfer, InpParsingError }