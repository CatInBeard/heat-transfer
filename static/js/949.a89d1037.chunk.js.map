{"version":3,"file":"static/js/949.a89d1037.chunk.js","mappings":"0DAKA,MAAMA,EAAmBC,IACrB,IAAIC,EAA+B,GAEnC,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAO,GAAGG,OAAQD,IAAK,CACvCD,EAAiBC,GAAK,GACtB,IAAK,IAAIE,EAAI,EAAGA,EAAIJ,EAAOG,OAAQC,IAC/BH,EAAiBC,GAAGG,KAAKL,EAAOI,GAAGF,GAE3C,CAEA,OAAOD,CAAgB,EA4BrBK,EAAiBA,CAACC,EAAeC,KACnC,MAAMC,EAAQF,EAAEJ,OACVO,EAAQH,EAAE,GAAGJ,OACbQ,EAAQH,EAAE,GAAGL,OAEnB,GAAIO,IAAUF,EAAEL,OACZ,MAAM,IAAIS,MAAM,iGAGpB,MAAMC,EAAgB,GAEtB,IAAK,IAAIX,EAAI,EAAGA,EAAIO,EAAOP,IAAK,CAC5BW,EAAEX,GAAK,GACP,IAAK,IAAIE,EAAI,EAAGA,EAAIO,EAAOP,IAAK,CAC5B,IAAIU,EAAM,EACV,IAAK,IAAIC,EAAI,EAAGA,EAAIL,EAAOK,IACvBD,GAAOP,EAAEL,GAAGa,GAAKP,EAAEO,GAAGX,GAE1BS,EAAEX,GAAGE,GAAKU,CACd,CACJ,CAEA,OAAOD,CAAC,EAwBNG,EAAyBA,CAAChB,EAAoBiB,KAChD,MAAMC,EAAOlB,EAAOG,OACdgB,EAAOnB,EAAO,GAAGG,OAEjBiB,EAAqB,GAE3B,IAAK,IAAIlB,EAAI,EAAGA,EAAIgB,EAAMhB,IAAK,CAC3BkB,EAAOlB,GAAK,GACZ,IAAK,IAAIE,EAAI,EAAGA,EAAIe,EAAMf,IACtBgB,EAAOlB,GAAGE,GAAKJ,EAAOE,GAAGE,GAAKa,CAEtC,CAEA,OAAOG,CAAM,EAoGjB,MA4CMC,EAAmBrB,IACrB,MAAMsB,EAAItB,EAAOG,OACXoB,EAAQC,MAAMF,GACdG,EAAQD,MAAMF,GAEpB,IAAK,IAAIpB,EAAI,EAAGA,EAAIoB,EAAGpB,IAAK,CACxBqB,EAAMrB,GAAK,GACXuB,EAAMvB,GAAK,GACX,IAAK,IAAIE,EAAI,EAAGA,EAAIkB,EAAGlB,IACnBmB,EAAMrB,GAAGE,GAAK,EACdqB,EAAMvB,GAAGE,GAAK,CAEtB,CAEA,IAAK,IAAIF,EAAI,EAAGA,EAAIoB,EAAGpB,IAAK,CACxB,IAAK,IAAIa,EAAIb,EAAGa,EAAIO,EAAGP,IAAK,CACxB,IAAID,EAAM,EACV,IAAK,IAAIV,EAAI,EAAGA,EAAIF,EAAGE,IACnBU,GAAQS,EAAMrB,GAAGE,GAAKqB,EAAMrB,GAAGW,GAEnCU,EAAMvB,GAAGa,GAAKf,EAAOE,GAAGa,GAAKD,CACjC,CAEA,IAAK,IAAIC,EAAIb,EAAGa,EAAIO,EAAGP,IACnB,GAAIb,IAAMa,EACNQ,EAAMrB,GAAGA,GAAK,MACX,CACH,IAAIY,EAAM,EACV,IAAK,IAAIV,EAAI,EAAGA,EAAIF,EAAGE,IACnBU,GAAQS,EAAMR,GAAGX,GAAKqB,EAAMrB,GAAGF,GAEnCqB,EAAMR,GAAGb,IAAMF,EAAOe,GAAGb,GAAKY,GAAOW,EAAMvB,GAAGA,EAClD,CAER,CAEA,MAAO,CAAEqB,MAAOA,EAAOE,MAAOA,EAAO,EA4BnCC,EAAe1B,IACjB,GAAIA,EAAOG,SAAWH,EAAO,GAAGG,OAC5B,MAAM,IAAIS,MAAM,yBAGpB,GAAsB,IAAlBZ,EAAOG,OACP,OAAOH,EAAO,GAAG,GAGrB,GAAsB,IAAlBA,EAAOG,OACP,OAAOH,EAAO,GAAG,GAAKA,EAAO,GAAG,GAAKA,EAAO,GAAG,GAAKA,EAAO,GAAG,GAGlE,IAAI2B,EAAM,EAEV,IAAK,IAAIzB,EAAI,EAAGA,EAAIF,EAAOG,OAAQD,IAC/ByB,GAAO3B,EAAO,GAAGE,GAAK0B,EAAS5B,EAAQ,EAAGE,GAG9C,OAAOyB,CAAG,EAGRC,EAAWA,CAAC5B,EAAoB6B,EAAaC,KAC/C,MAAMC,EAAY/B,EAAOgC,QAAO,CAACC,EAAGC,IAAMA,IAAML,IAAKM,KAAIN,GAAOA,EAAIG,QAAO,CAACC,EAAGG,IAAMA,IAAMN,MAG3F,QAFcD,EAAMC,GAAO,IAAM,EAAI,GAAK,GAE5BJ,EAAYK,EAAU,E,2BCxUxC,MAwGMM,EAAqBA,CAACC,EAASC,EAAgBC,KAEjD,IAAIC,EAAIC,EAAsBJ,EAASE,GAEvCC,EAAIE,EAAmBF,EAAGH,GAE1B,IAAIM,EAAIC,EAAsBP,EAASC,GAIvC,OAFmBO,EDqKWC,EAACxC,EAAeyC,KAC9C,MAAMC,EAAK5B,EAAgBd,GACrBe,EAAIf,EAAEJ,OACN+C,EAAc,GACdC,EAAc,GAEpB,IAAK,IAAIjD,EAAI,EAAGA,EAAIoB,EAAGpB,IAAK,CACxB,IAAIY,EAAM,EACV,IAAK,IAAIV,EAAI,EAAGA,EAAIF,EAAGE,IACnBU,GAAOmC,EAAG1B,MAAMrB,GAAGE,GAAK8C,EAAE9C,GAE9B8C,EAAEhD,IAAM8C,EAAE9C,GAAKY,GAAOmC,EAAG1B,MAAMrB,GAAGA,EACtC,CAEA,IAAK,IAAIA,EAAIoB,EAAI,EAAGpB,GAAK,EAAGA,IAAK,CAC7B,IAAIY,EAAM,EACV,IAAK,IAAIV,EAAIF,EAAI,EAAGE,EAAIkB,EAAGlB,IACvBU,GAAOmC,EAAGxB,MAAMvB,GAAGE,GAAK+C,EAAE/C,GAE9B+C,EAAEjD,IAAMgD,EAAEhD,GAAKY,GAAOmC,EAAGxB,MAAMvB,GAAGA,EACtC,CAEA,OAAOiD,CAAC,EC3LgCJ,CAA0BN,EAAGG,GAAIN,EAASC,EAE/D,EAgCjBM,EAAwBA,CAACP,EAASC,KACpC,IAAIpC,EAASmC,EAAQc,YAAY,GAAGC,MAAMlD,OAEtCyC,EAAcpB,MAAMrB,GACxB,IAAK,IAAID,EAAI,EAAGA,EAAIC,EAAQD,IACxB0C,EAAE1C,GAAK,EAGX,IAAK,IAAIA,EAAI,EAAGA,EAAIqC,EAAepC,OAAQD,IAAK,CAC5C,IAAIoD,EAAoBf,EAAerC,GAEnCmD,EAAkBE,EAA0BD,EAAGE,QAASlB,GAE5D,IAAK,IAAIpC,EAAI,EAAGA,EAAImD,EAAMlD,OAAQD,IAAK,CAEnC0C,EADmBS,EAAMnD,GAChB,GAAKoD,EAAGG,WACrB,CAEJ,CAEA,OAAOb,CAAC,EAGNW,EAA4BA,CAACC,EAAiBlB,KAEhD,IAAIoB,EAAyBpB,EAAkB,SAAEqB,MAAMC,MAAMF,GAClDA,EAAKG,SAAWL,IAE3B,IAAKE,EACD,MAAM,IAAI9C,MAAM,iBAGpB,OAAO8C,EAAKL,KAAK,EAIfV,EAAqBA,CAACF,EAAyBH,KAEjDA,EAAQwB,MAAM,GAAGC,WAAWN,YAAYO,SAASP,IAC7C,IAAID,EAAUC,EAAYD,QACtBE,EAAyBpB,EAAQ2B,SAASN,MAAMC,MAAMF,GAC/CA,EAAKG,SAAWL,IAE3B,IAAKE,EACD,MAAM,IAAI9C,MAAM,kBAGpB8C,EAAKL,MAAMW,SAASE,IAChB,IAAK,IAAIhE,EAAI,EAAGA,EAAIuC,EAAEtC,OAAQD,IAC1BuC,EAAEyB,EAAO,GAAGhE,GAAK,EAErBuC,EAAEyB,EAAO,GAAGA,EAAO,GAAK,CAAC,GAC3B,IAICzB,GAkGL0B,EAA2BA,CAACC,EAAiB5B,EAA4B6B,EAAeC,KAAiC,IAADC,EAE1H,IAAIC,EAAOH,EAAMT,MAAMa,IACwB,GAApCA,EAAMC,SAASC,QAAQP,KAElC,IAAKI,EACD,MAAM,IAAI5D,MAAM,wBAEpB,IAAIgE,EAAmBJ,EAAKX,QACxBgB,EAAUP,EAASV,MAAMiB,GAClBA,EAAQC,WAAaF,IAEhC,IAAKC,EACD,MAAM,IAAIjE,MAAM,wBAIpB,OAA8C,QAA9C2D,EAAO/B,EAFWqC,EAAQE,aAEoB,IAAAR,EAAAA,EAAI,CAAC,EAqGvD,MAAM7B,EAAwBA,CAACJ,EAASE,KAEpC,IAAIa,EAAQf,EAAQc,YAAY,GAAGC,MAC/BqB,EAAWpC,EAAQc,YAAY,GAAGsB,SAElCjC,EAAgB,IAAIjB,MAAM6B,EAAMlD,QACpC,IAAK,IAAID,EAAI,EAAGA,EAAIuC,EAAEtC,OAAQD,IAC1BuC,EAAEvC,GAAK,IAAIsB,MAAM6B,EAAMlD,QAAQ6E,KAAK,GAGxC,IAAK,IAAI9E,EAAI,EAAGA,EAAIwE,EAASvE,OAAQD,IAAK,CAEtC,IAAI+E,EAAed,EAAyBO,EAASxE,GAAG,GAAIsC,EAA4BF,EAAQc,YAAY,GAAGiB,MAAO/B,EAAQc,YAAY,GAAGkB,UACzIY,EAAgB,CAAC,GAAI,GAAI,IAC7B,IAAK,IAAI9E,EAAI,EAAGA,GAAK,EAAGA,IACpB8E,EAAE9E,EAAI,GAAK,CAACiD,EAAMqB,EAASxE,GAAGE,GAAK,GAAG,GAAIiD,EAAMqB,EAASxE,GAAGE,GAAK,GAAG,IAGxE8E,EAAInF,EAAgBmF,GAEpB,IAAIC,EAAKC,EAA2BF,EAAGD,GACvCxC,EAAI4C,EAAyB5C,EAAG0C,EAAIT,EAASxE,GAAG,GAAIwE,EAASxE,GAAG,GAAIwE,EAASxE,GAAG,GAEpF,CAEA,OAAOuC,CAAC,EAiCN2C,EAA6BA,CAACE,EAAoBC,KAEpD,IAAIC,EAAI,CACJ,CAACF,EAAO,GAAG,GAAKA,EAAO,GAAG,GAAIA,EAAO,GAAG,GAAKA,EAAO,GAAG,IACvD,CAACA,EAAO,GAAG,GAAKA,EAAO,GAAG,GAAIA,EAAO,GAAG,GAAKA,EAAO,GAAG,KAQvD9E,EAAIF,ED5XZ,SAAuBN,GACnB,IAsBA,SAAwBA,GACtB,MAAMsB,EAAItB,EAAOG,OACjB,IAAK,IAAID,EAAI,EAAGA,EAAIoB,EAAGpB,IACrB,GAAIF,EAAOE,GAAGC,SAAWmB,EACvB,OAAO,EAGX,OAAO,CACT,CA9BKmE,CAAezF,GAClB,MAAM,IAAIY,MAAM,yBAGlB,MAAMe,EAAM+D,EAAqB1F,GAEjC,GAAY,IAAR2B,EACA,MAAM,IAAIf,MAAM,oBAGpB,MACM+E,EA4DN,SAAyB3F,GACvB,MAAM4F,EAAyB,GAC/B,IAAK,IAAI1F,EAAI,EAAGA,EAAIF,EAAO,GAAGG,OAAQD,IAAK,CACzC0F,EAAW1F,GAAK,GAChB,IAAK,IAAIE,EAAI,EAAGA,EAAIJ,EAAOG,OAAQC,IACjCwF,EAAW1F,GAAGE,GAAKJ,EAAOI,GAAGF,EAEjC,CACA,OAAO0F,CACT,CArEgB7F,CAsChB,SAA4BC,GAC1B,MAAM6F,EAAwB,GAC9B,IAAK,IAAI3F,EAAI,EAAGA,EAAIF,EAAOG,OAAQD,IAAK,CACtC2F,EAAU3F,GAAK,GACf,IAAK,IAAIE,EAAI,EAAGA,EAAIJ,EAAOE,GAAGC,OAAQC,IACpCyF,EAAU3F,GAAGE,KACR,KAAOF,EAAIE,GACdsF,EAAqBI,EAAa9F,EAAQE,EAAGE,GAEnD,CACA,OAAOyF,CACT,CAlDkBE,CAAmB/F,IAGrC,IAAK,IAAIE,EAAI,EAAGA,EAAIF,EAAOG,OAAQD,IACjC,IAAK,IAAIE,EAAI,EAAGA,EAAIJ,EAAOE,GAAGC,OAAQC,IACpCuF,EAAQzF,GAAGE,IAAMuB,EAIrB,OAAOgE,EAaP,SAASD,EAAqB1F,GAC5B,GAAsB,IAAlBA,EAAOG,OACT,OAAOH,EAAO,GAAG,GAGnB,IAAI2B,EAAM,EACV,IAAK,IAAIzB,EAAI,EAAGA,EAAIF,EAAOG,OAAQD,IACjCyB,GACE3B,EAAO,GAAGE,GACVwF,EACEI,EAAa9F,EAAQ,EAAGE,MAEvB,IAAMA,EAEb,OAAOyB,CACT,CAeA,SAASmE,EAAa9F,EAAoB6B,EAAaC,GACrD,MAAMkE,EAAwB,GAC9B,IAAK,IAAI9F,EAAI,EAAGA,EAAIF,EAAOG,OAAQD,IAC7BA,IAAM2B,GACVmE,EAAU3F,KAAKL,EAAOE,GAAG8B,QAAO,CAACC,EAAGG,IAAMA,GAAKN,KAEjD,OAAOkE,CACT,CAYF,CC0SyBC,CAAcT,GAL1B,CACP,EAAE,EAAG,EAAG,GACR,EAAE,EAAG,EAAG,KAIZ,OAAOlF,EAAeU,EAAuBjB,EAAgBS,GAAI+E,GAASvE,EAAuBR,EAAGkB,EAAY8D,GAAK,GAAG,EAqCtHH,EAA2BA,CAACa,EAAoCC,EAAmCjG,EAAWE,EAAWW,KAG3HX,IACAW,IAEAmF,IAJAhG,GAIgBA,IAAMiG,EAAY,GAAG,GACrCD,EAAa9F,GAAGA,IAAM+F,EAAY,GAAG,GACrCD,EAAanF,GAAGA,IAAMoF,EAAY,GAAG,GAErCD,EAAahG,GAAGE,IAAM+F,EAAY,GAAG,GACrCD,EAAa9F,GAAGF,IAAMiG,EAAY,GAAG,GAErCD,EAAahG,GAAGa,IAAMoF,EAAY,GAAG,GACrCD,EAAanF,GAAGb,IAAMiG,EAAY,GAAG,GAErCD,EAAa9F,GAAGW,IAAMoF,EAAY,GAAG,GACrCD,EAAanF,GAAGX,IAAM+F,EAAY,GAAG,GAE9BD,GAGLpD,EAAuB,SAACW,EAAuBnB,EAASC,GAA2C,IAA3B6D,EAAQC,UAAAlG,OAAA,QAAAmG,IAAAD,UAAA,GAAAA,UAAA,GAAE,EAEpF,IAAK,IAAInG,EAAI,EAAGA,EAAIqC,EAAepC,OAAQD,IAAK,CAC5C,IAAIoD,EAA8Bf,EAAerC,GAE7CmD,EAAkBE,EAA0BD,EAAGE,QAASlB,GAExDiE,GAAOC,EAAAA,EAAAA,GAAuBlD,EAAGG,YAAYgD,WAAWL,GAE5D,IAAK,IAAIlG,EAAI,EAAGA,EAAImD,EAAMlD,OAAQD,IAAK,CAEnCuD,EADmBJ,EAAMnD,GACN,GAAKqG,CAC5B,CAEJ,CAEA,OAAO9C,CACX,ECzjBoBiD,KAEhBC,iBAAiB,WAAYC,IAE7B,IAAItE,EAAUsE,EAAMC,KAAKvE,QACrBC,EAAiBqE,EAAMC,KAAKtE,eAC5BC,EAA6BoE,EAAMC,KAAKrE,2BAExCpB,EAAmB,GACvB,IACIA,EAASiB,EAAmBC,EAASC,EAAgBC,EACzD,CACA,MAAOsE,GACHC,YAAY,CAAEC,OAAQ,QAAS5F,OAAQ0F,GAC3C,CACAC,YAAY,CAAEC,OAAQ,OAAQ5F,OAAQA,GAAS,G,qNChBnD,MAAMoF,uBAAyBA,CAACS,WAAoBb,KAEhD,MAAMc,MAAQD,WAAWE,MAAM,MAE/B,GAAGD,MAAM/G,OAAS,GAAK+G,MAAM,GAAGE,SAAS,KAAK,CAC1C,MAAMC,GAAYC,EAAAA,oCAAAA,GAASL,YACrBM,GAAQC,EAAAA,oCAAAA,GAAeH,EAAWjB,GAExC,OAAOmB,CACX,CAEAN,WAAaA,WAAWQ,QAAQ,YAAa,mBAC7CR,WAAaA,WAAWQ,QAAQ,OAAQ,YACxCR,WAAaA,WAAWQ,QAAQ,OAAQ,YAExC,MAAMrG,OAAiBsG,KAAKT,YAG5B,OAAO7F,MAAM,C,yCCrBjB,MAAMkG,EAAYK,IAEd,MAAMT,EAAQS,EAAQR,MAAM,MACtB/F,EAAkB,GAExB,IAAK,IAAIlB,EAAI,EAAGA,EAAIgH,EAAM/G,OAAQD,IAAK,CACnC,MAAO0H,EAAMnE,GAAeyD,EAAMhH,GAAGiH,MAAM,KAC3C/F,EAAOyG,WAAWD,IAASC,WAAWpE,EAC1C,CAEA,OAAOrC,CAAM,EAKjB,SAASoG,EAAerF,EAAeoF,GAGrC,MAAMO,EAAaC,OAAOC,KAAK7F,GAAK8F,MAAK,CAACC,EAAQlF,IAAWkF,EAAIlF,IAC3DmF,EAAahG,EAAI2F,EAAW,IAElC,GAAGP,GAAS,GAAKA,GAASM,WAAWC,EAAW,IAC9C,OAAOK,EAGT,MAAMH,EAAOD,OAAOC,KAAK7F,GAAKA,KAAKpB,GAAM8G,WAAW9G,KAC9CqH,EAAWJ,EAAKpE,MAAM7C,GAAMA,GAAKwG,IACjCc,EAAWL,EAAKpE,MAAM7C,GAAMA,GAAKwG,IAEvC,QAAiBjB,IAAb8B,EACF,OAAOjG,EAAI6F,EAAK,IACX,QAAiB1B,IAAb+B,EACT,OAAOlG,EAAI6F,EAAKA,EAAK7H,OAAS,IAGhC,MAAMmI,EAAanG,EAAIiG,GACjBG,EAAapG,EAAIkG,GACjBG,GAAUjB,EAAQa,IAAaC,EAAWD,GAEhD,OAAQ,EAAII,GAAUF,EAAaE,EAASD,CAC9C,C,GCvCIE,yBAA2B,CAAC,EAGhC,SAASC,oBAAoBC,GAE5B,IAAIC,EAAeH,yBAAyBE,GAC5C,QAAqBrC,IAAjBsC,EACH,OAAOA,EAAaC,QAGrB,IAAIC,EAASL,yBAAyBE,GAAY,CACjDI,GAAIJ,EACJK,QAAQ,EACRH,QAAS,CAAC,GAUX,OANAI,oBAAoBN,GAAUO,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASH,qBAG3EI,EAAOE,QAAS,EAGTF,EAAOD,OACf,CAGAH,oBAAoBS,EAAIF,oBAGxBP,oBAAoBvF,EAAI,KAGvB,IAAIiG,EAAsBV,oBAAoBW,OAAE/C,EAAW,CAAC,KAAK,IAAOoC,oBAAoB,OAE5F,OADAU,EAAsBV,oBAAoBW,EAAED,EAClB,E,MCpC3B,IAAIE,EAAW,GACfZ,oBAAoBW,EAAI,CAACjI,EAAQmI,EAAUC,EAAIC,KAC9C,IAAGF,EAAH,CAMA,IAAIG,EAAeC,IACnB,IAASzJ,EAAI,EAAGA,EAAIoJ,EAASnJ,OAAQD,IAAK,CACrCqJ,EAAWD,EAASpJ,GAAG,GACvBsJ,EAAKF,EAASpJ,GAAG,GACjBuJ,EAAWH,EAASpJ,GAAG,GAE3B,IAJA,IAGI0J,GAAY,EACPxJ,EAAI,EAAGA,EAAImJ,EAASpJ,OAAQC,MACpB,EAAXqJ,GAAsBC,GAAgBD,IAAa1B,OAAOC,KAAKU,oBAAoBW,GAAGQ,OAAOC,GAASpB,oBAAoBW,EAAES,GAAKP,EAASnJ,MAC9ImJ,EAASQ,OAAO3J,IAAK,IAErBwJ,GAAY,EACTH,EAAWC,IAAcA,EAAeD,IAG7C,GAAGG,EAAW,CACbN,EAASS,OAAO7J,IAAK,GACrB,IAAIgC,EAAIsH,SACElD,IAANpE,IAAiBd,EAASc,EAC/B,CACD,CACA,OAAOd,CArBP,CAJCqI,EAAWA,GAAY,EACvB,IAAI,IAAIvJ,EAAIoJ,EAASnJ,OAAQD,EAAI,GAAKoJ,EAASpJ,EAAI,GAAG,GAAKuJ,EAAUvJ,IAAKoJ,EAASpJ,GAAKoJ,EAASpJ,EAAI,GACrGoJ,EAASpJ,GAAK,CAACqJ,EAAUC,EAAIC,EAuBjB,C,KC3Bdf,oBAAoBsB,EAAI,CAACnB,EAASoB,KACjC,IAAI,IAAIH,KAAOG,EACXvB,oBAAoBwB,EAAED,EAAYH,KAASpB,oBAAoBwB,EAAErB,EAASiB,IAC5E/B,OAAOoC,eAAetB,EAASiB,EAAK,CAAEM,YAAY,EAAMC,IAAKJ,EAAWH,IAE1E,ECNDpB,oBAAoB4B,EAAI,CAAC,EAGzB5B,oBAAoB5B,EAAKyD,GACjBC,QAAQC,IAAI1C,OAAOC,KAAKU,oBAAoB4B,GAAGI,QAAO,CAACC,EAAUb,KACvEpB,oBAAoB4B,EAAER,GAAKS,EAASI,GAC7BA,IACL,KCNJjC,oBAAoBkC,EAAKL,GAEjB,aAAeA,EAAf,qBCFR7B,oBAAoBmC,SAAYN,IAEf,ECHjB7B,oBAAoBoC,EAAI,WACvB,GAA0B,kBAAfC,WAAyB,OAAOA,WAC3C,IACC,OAAOC,MAAQ,IAAIC,SAAS,cAAb,EAChB,CAAE,MAAOnE,GACR,GAAsB,kBAAXoE,OAAqB,OAAOA,MACxC,CACA,CAPuB,GCAxBxC,oBAAoBwB,EAAI,CAACiB,EAAKC,IAAUrD,OAAOsD,UAAUC,eAAepC,KAAKiC,EAAKC,GCAlF1C,oBAAoB6C,IAAOzC,IAC1BA,EAAO0C,MAAQ,GACV1C,EAAO2C,WAAU3C,EAAO2C,SAAW,IACjC3C,GCHRJ,oBAAoBgD,EAAI,kB,MCIxB,IAAIC,EAAkB,CACrB,IAAK,GAkBNjD,oBAAoB4B,EAAEpK,EAAI,CAACqK,EAASI,KAE/BgB,EAAgBpB,IAElBqB,cAAclD,oBAAoBgD,EAAIhD,oBAAoBkC,EAAEL,GAE9D,EAGD,IAAIsB,EAAqBnF,KAAgC,0BAAIA,KAAgC,2BAAK,GAC9FoF,EAA6BD,EAAmBxL,KAAK0L,KAAKF,GAC9DA,EAAmBxL,KAzBCwG,IACnB,IAAI0C,EAAW1C,EAAK,GAChBmF,EAAcnF,EAAK,GACnBoF,EAAUpF,EAAK,GACnB,IAAI,IAAI8B,KAAYqD,EAChBtD,oBAAoBwB,EAAE8B,EAAarD,KACrCD,oBAAoBS,EAAER,GAAYqD,EAAYrD,IAIhD,IADGsD,GAASA,EAAQvD,qBACda,EAASpJ,QACdwL,EAAgBpC,EAAS2C,OAAS,EACnCJ,EAA2BjF,EAAK,C,WCrBjC,IAAIsF,EAAOzD,oBAAoBvF,EAC/BuF,oBAAoBvF,EAAI,IAChBuF,oBAAoB5B,EAAE,IAAIsF,KAAKD,E,KCDvC,IAAI/C,oBAAsBV,oBAAoBvF,G","sources":["matrix.tsx","computeHeatTransfer.tsx","computeSteadyWorker.ts","mathExpression.ts","table.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["type LU = {\n    lower: number[][],\n    upper: number[][]\n}\n\nconst transposeMatrix = (matrix: number[][]): number[][] => {\n    let transposedMatrix: number[][] = [];\n\n    for (let i = 0; i < matrix[0].length; i++) {\n        transposedMatrix[i] = [];\n        for (let j = 0; j < matrix.length; j++) {\n            transposedMatrix[i].push(matrix[j][i]);\n        }\n    }\n\n    return transposedMatrix;\n}\n\nconst SumMatrix = (A: number[][], B: number[][]): number[][] => {\n\n    let C = new Array(A[0].length);\n\n    for (let i = 0; i < A.length; i++) {\n        C[i] = new Array(A[0].length);\n        for (let j = 0; j < A[0].length; j++) {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n\n    return C;\n}\n\nconst SumVector = (A: number[], B: number[]): number[] => {\n\n    let C = new Array(A.length);\n\n    for (let i = 0; i < A.length; i++) {\n        C[i] = A[i] + B[i];\n    }\n\n    return C;\n}\n\nconst MultiplyMatrix = (A: number[][], B: number[][]): number[][] => {\n    const rows1 = A.length;\n    const cols1 = A[0].length;\n    const cols2 = B[0].length;\n\n    if (cols1 !== B.length) {\n        throw new Error(\"The number of columns in the first matrix must match the number of rows in the second matrix.\");\n    }\n\n    const C: number[][] = [];\n\n    for (let i = 0; i < rows1; i++) {\n        C[i] = [];\n        for (let j = 0; j < cols2; j++) {\n            let sum = 0;\n            for (let k = 0; k < cols1; k++) {\n                sum += A[i][k] * B[k][j];\n            }\n            C[i][j] = sum;\n        }\n    }\n\n    return C;\n}\n\nconst MultiplyMatrixByVector = (A: number[][], v: number[]): number[] => {\n    const rows = A.length;\n    const cols = A[0].length;\n\n    if (cols !== v.length) {\n        throw new Error(\"The number of columns in the matrix must match the length of the vector.\");\n    }\n\n    const result: number[] = [];\n\n    for (let i = 0; i < rows; i++) {\n        let sum = 0;\n        for (let j = 0; j < cols; j++) {\n            sum += A[i][j] * v[j];\n        }\n        result[i] = sum;\n    }\n\n    return result;\n}\n\nconst multiplyMatrixByNumber = (matrix: number[][], number: number): number[][] => {\n    const rows = matrix.length;\n    const cols = matrix[0].length;\n\n    const result: number[][] = [];\n\n    for (let i = 0; i < rows; i++) {\n        result[i] = [];\n        for (let j = 0; j < cols; j++) {\n            result[i][j] = matrix[i][j] * number;\n        }\n    }\n\n    return result;\n}\n\nconst multiplyVectorByNumber = (matrix: number[], number: number): number[] => {\n\n    const result: number[] = [];\n\n    for (let i = 0; i < matrix.length; i++) {\n        result[i] = matrix[i] * number;\n    }\n\n    return result;\n}\n\nfunction InverseMatrix(matrix: number[][]): number[][] {\n    if (!isSquareMatrix(matrix)) {\n      throw new Error(\"Matrix must be square\");\n    }\n  \n    const det = calculateDeterminant(matrix);\n  \n    if (det === 0) {\n        throw new Error(\"Matrix has 0 det\");\n    }\n  \n    const cofactors = calculateCofactors(matrix);\n    const adjoint = transposeMatrix(cofactors);\n  \n    for (let i = 0; i < matrix.length; i++) {\n      for (let j = 0; j < matrix[i].length; j++) {\n        adjoint[i][j] /= det;\n      }\n    }\n\n    return adjoint;\n\n  \n    function isSquareMatrix(matrix: number[][]): boolean {\n      const n = matrix.length;\n      for (let i = 0; i < n; i++) {\n        if (matrix[i].length !== n) {\n          return false;\n        }\n      }\n      return true;\n    }\n  \n    function calculateDeterminant(matrix: number[][]): number {\n      if (matrix.length === 1) {\n        return matrix[0][0];\n      }\n  \n      let det = 0;\n      for (let i = 0; i < matrix.length; i++) {\n        det +=\n          matrix[0][i] *\n          calculateDeterminant(\n            getSubmatrix(matrix, 0, i)\n          ) *\n          ((-1) ** i);\n      }\n      return det;\n    }\n  \n    function calculateCofactors(matrix: number[][]): number[][] {\n      const cofactors: number[][] = [];\n      for (let i = 0; i < matrix.length; i++) {\n        cofactors[i] = [];\n        for (let j = 0; j < matrix[i].length; j++) {\n          cofactors[i][j] =\n            ((-1) ** (i + j)) *\n            calculateDeterminant(getSubmatrix(matrix, i, j));\n        }\n      }\n      return cofactors;\n    }\n  \n    function getSubmatrix(matrix: number[][], row: number, col: number): number[][] {\n      const submatrix: number[][] = [];\n      for (let i = 0; i < matrix.length; i++) {\n        if (i === row) continue;\n        submatrix.push(matrix[i].filter((_, c) => c != col));\n      }\n      return submatrix;\n    }\n  \n    function transposeMatrix(matrix: number[][]): number[][] {\n      const transposed: number[][] = [];\n      for (let i = 0; i < matrix[0].length; i++) {\n        transposed[i] = [];\n        for (let j = 0; j < matrix.length; j++) {\n          transposed[i][j] = matrix[j][i];\n        }\n      }\n      return transposed;\n    }\n  }\n  \n\n\nconst InverseMatrixLU = (A: number[][]) => { // LU inverse matrix\n    if (A.length != A[0].length) {\n        throw new Error(\"The matrix is not square\");\n    }\n\n    const n = A.length;\n    const identity = Array(n);\n    const inverse = Array(n);\n\n    for (let i = 0; i < n; i++) {\n        identity[i] = [];\n        inverse[i] = [];\n        for (let j = 0; j < n; j++) {\n            identity[i][j] = (i === j) ? 1 : 0;\n            inverse[i][j] = 0;\n        }\n    }\n\n    let LU = luDecomposition(A);\n\n    for (let k = 0; k < n; k++) {\n        const y = Array(n);\n        const b = Array(n);\n        for (let i = 0; i < n; i++) {\n            y[i] = 0;\n            b[i] = identity[i][k];\n            for (let j = 0; j < i; j++) {\n                y[i] += (LU.lower[i][j] * y[j]);\n            }\n            y[i] = (b[i] - y[i]) / LU.lower[i][i];\n        }\n        for (let i = n - 1; i >= 0; i--) {\n            inverse[i][k] = y[i];\n            for (let j = i + 1; j < n; j++) {\n                inverse[i][k] -= (LU.upper[i][j] * inverse[j][k]);\n            }\n            inverse[i][k] = inverse[i][k] / LU.upper[i][i];\n        }\n    }\n\n    return inverse;\n\n}\n\nconst luDecomposition = (matrix: number[][]): LU => {\n    const n = matrix.length;\n    const lower = Array(n);\n    const upper = Array(n);\n\n    for (let i = 0; i < n; i++) {\n        lower[i] = [];\n        upper[i] = [];\n        for (let j = 0; j < n; j++) {\n            lower[i][j] = 0;\n            upper[i][j] = 0;\n        }\n    }\n\n    for (let i = 0; i < n; i++) {\n        for (let k = i; k < n; k++) {\n            let sum = 0;\n            for (let j = 0; j < i; j++) {\n                sum += (lower[i][j] * upper[j][k]);\n            }\n            upper[i][k] = matrix[i][k] - sum;\n        }\n\n        for (let k = i; k < n; k++) {\n            if (i === k) {\n                lower[i][i] = 1;\n            } else {\n                let sum = 0;\n                for (let j = 0; j < i; j++) {\n                    sum += (lower[k][j] * upper[j][i]);\n                }\n                lower[k][i] = (matrix[k][i] - sum) / upper[i][i];\n            }\n        }\n    }\n\n    return { lower: lower, upper: upper };\n}\n\nconst solveLinearEquationSystem = (A: number[][], b: number[]): number[] => {\n    const LU = luDecomposition(A);\n    const n = A.length;\n    const y: number[] = [];\n    const x: number[] = [];\n\n    for (let i = 0; i < n; i++) {\n        let sum = 0;\n        for (let j = 0; j < i; j++) {\n            sum += LU.lower[i][j] * y[j];\n        }\n        y[i] = (b[i] - sum) / LU.lower[i][i];\n    }\n\n    for (let i = n - 1; i >= 0; i--) {\n        let sum = 0;\n        for (let j = i + 1; j < n; j++) {\n            sum += LU.upper[i][j] * x[j];\n        }\n        x[i] = (y[i] - sum) / LU.upper[i][i];\n    }\n\n    return x;\n}\n\nconst Determinant = (matrix: number[][]): number => {\n    if (matrix.length !== matrix[0].length) {\n        throw new Error(\"Matrix must be square\");\n    }\n\n    if (matrix.length === 1) {\n        return matrix[0][0];\n    }\n\n    if (matrix.length === 2) {\n        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];\n    }\n\n    let det = 0;\n\n    for (let i = 0; i < matrix.length; i++) {\n        det += matrix[0][i] * cofactor(matrix, 0, i);\n    }\n\n    return det;\n}\n\nconst cofactor = (matrix: number[][], row: number, col: number): number => {\n    const subMatrix = matrix.filter((_, r) => r !== row).map(row => row.filter((_, c) => c !== col));\n    const sign = (row + col) % 2 === 0 ? 1 : -1;\n    \n    return sign * Determinant(subMatrix);\n}\n\nconst frobeniusNorm = (matrix: number[][]): number => {\n    let sum = 0;\n    \n    for (let i = 0; i < matrix.length; i++) {\n        for (let j = 0; j < matrix[i].length; j++) {\n            sum += matrix[i][j] ** 2;\n        }\n    }\n    \n    return Math.sqrt(sum); \n}\n\n\n\nexport { transposeMatrix, SumMatrix, MultiplyMatrixByVector, multiplyVectorByNumber, SumVector, MultiplyMatrix, InverseMatrix, multiplyMatrixByNumber, solveLinearEquationSystem, Determinant, frobeniusNorm, InverseMatrixLU }","import { transposeMatrix, MultiplyMatrix, MultiplyMatrixByVector, SumVector, multiplyVectorByNumber, solveLinearEquationSystem, multiplyMatrixByNumber, InverseMatrix, Determinant, InverseMatrixLU } from \"./matrix\";\nimport { Nset, Lset, Section, TemperatureBC, TemperatureBCTransitive } from \"./inpParse\"\nimport { multiplyMatrixByNumberBig, SumVectorBig, multiplyVectorByNumberBig, MultiplyMatrixByVectorBig, solveLinearEquationSystemBig } from \"./bigMatrix\"\nimport { evaluateMathExpression } from \"./mathExpression\"\nimport { cloneDeep } from 'lodash';\nimport Big from 'big.js';\n\n\nconst computeTransitive = (inpData, temperature_BC, blocks_termal_conductivity, blocks_density, blocks_capacity, progress_callback, initialTemp = 0, timeStep = 0.1, steps = 500, useBig = false) => {\n\n    Big.DP = 60;\n\n    let freq = 1 / timeStep;\n\n    let K: number[][] = getConductivityMatrixTransitive(inpData, blocks_termal_conductivity);\n\n    let C: number[][] = getCapacityMatrix(inpData, blocks_density, blocks_capacity);\n\n    let KForF = applyTemperatureBCToKTransitive(K, inpData);\n\n\n    let F: number[] = getFForTransitive(KForF, inpData);\n\n    K = cloneDeep(KForF)\n\n    K = applyTemperatureBCToKTransitiveStep2(K, inpData);\n\n\n    if (progress_callback === null) {\n        progress_callback = (progress, data) => {\n            console.log(\"progress: \" + progress + \"%\")\n        }\n    }\n\n    let temperaturePrevStep: number[] = [];\n    let temperatureCurrentStep: number[] = [];\n\n    for (let i = 0; i < F.length; i++) {\n        temperaturePrevStep.push(initialTemp);\n    }\n    temperaturePrevStep = fixTemperatureFromBC(temperaturePrevStep, inpData, temperature_BC)\n\n    let temperatureFrames: number[][] = [];\n\n    temperatureFrames.push(temperaturePrevStep);\n\n    let progress = 0;\n\n    let realTime = 0;\n\n    if (useBig) {\n        let bigC = floatMatrixToBig(C);\n        let bigK = floatMatrixToBig(K);\n        let bigFreq = new Big(freq);\n        let bigF = floatVectorToBig(F);\n        let bigTemperaturePrevStep = floatVectorToBig(temperaturePrevStep);\n        let bigTemperatureCurrentStep: Big[] = [];\n\n        for (let t = 0; t < steps; t++) {\n\n\n            let A = multiplyMatrixByNumberBig(bigC, bigFreq)\n            let b = SumVectorBig(\n                SumVectorBig(bigF, multiplyVectorByNumberBig(\n                    MultiplyMatrixByVectorBig(bigK, bigTemperaturePrevStep), new Big(-1))),\n                multiplyVectorByNumberBig(\n                    MultiplyMatrixByVectorBig(bigC, bigTemperaturePrevStep), bigFreq))\n\n            let Temperature = solveLinearEquationSystemBig(A, b)\n\n            bigTemperatureCurrentStep = fixTemperatureFromBCBig(Temperature, inpData, temperature_BC)\n\n            let vector = BigVectorToFloat(bigTemperatureCurrentStep)\n            temperatureFrames.push(vector);\n            bigTemperaturePrevStep = bigTemperatureCurrentStep;\n\n            progress += 100 / steps\n            progress_callback(progress, vector)\n        }\n    }\n    else {\n        for (let t = 0; t < steps; t++) {\n\n            F = getFForTransitive(KForF, inpData, realTime);\n\n            let A = multiplyMatrixByNumber(C, freq)\n            let b = SumVector(\n                SumVector(F, multiplyVectorByNumber(\n                    MultiplyMatrixByVector(K, temperaturePrevStep), -1)),\n                multiplyVectorByNumber(\n                    MultiplyMatrixByVector(C, temperaturePrevStep), freq))\n            let Temperature = solveLinearEquationSystem(A, b)\n\n            temperatureCurrentStep = fixTemperatureFromBC(Temperature, inpData, temperature_BC, realTime)\n\n            temperatureCurrentStep = Temperature\n\n            temperatureFrames.push(temperatureCurrentStep);\n            temperaturePrevStep = temperatureCurrentStep;\n\n            progress += 100 / steps\n            progress_callback(progress, temperatureCurrentStep)\n            realTime += timeStep\n        }\n    }\n\n\n    return temperatureFrames;\n\n}\n\n\nconst computeSteadyState = (inpData, temperature_BC, blocks_termal_conductivity) => {\n\n    let K = getConductivityMatrix(inpData, blocks_termal_conductivity);\n\n    K = applyTemperatureBC(K, inpData);\n\n    let F = getTermalForcesFromBC(inpData, temperature_BC);\n\n    let temperatures = fixTemperatureFromBC(solveLinearEquationSystem(K, F), inpData, temperature_BC);\n\n    return temperatures\n\n}\n\nconst floatVectorToBig = (F: number[]): Big[] => {\n    let bigF: Big[] = [];\n    for (let i = 0; i < F.length; i++) {\n        bigF[i] = new Big(F[i]);\n    }\n    return bigF;\n}\n\nconst BigVectorToFloat = (bigF: Array<Big>): number[] => {\n    let F: number[] = [];\n    for (let i = 0; i < bigF.length; i++) {\n        F[i] = bigF[i].toNumber()\n    }\n    return F;\n}\n\nconst floatMatrixToBig = (A: number[][]): Big[][] => {\n    let bigA: Big[][] = [];\n    for (let i = 0; i < A.length; i++) {\n        bigA[i] = [];\n        for (let j = 0; j < A.length; j++) {\n            bigA[i][j] = new Big(A[i][j]);\n        }\n    }\n    return bigA;\n}\n\n\nconst getTermalForcesFromBC = (inpData, temperature_BC): number[] => {\n    let length = inpData.problemData[0].nodes.length;\n\n    let F: number[] = Array(length);\n    for (let i = 0; i < length; i++) {\n        F[i] = 0;\n    }\n\n    for (let i = 0; i < temperature_BC.length; i++) {\n        let BC: TemperatureBC = temperature_BC[i];\n\n        let nodes: number[] = getNodesByAssemblySetName(BC.setName, inpData);\n\n        for (let i = 0; i < nodes.length; i++) {\n            let node: number = nodes[i];\n            F[node - 1] = BC.temperature;\n        }\n\n    }\n\n    return F;\n}\n\nconst getNodesByAssemblySetName = (setName: string, inpData): number[] => {\n\n    let nset: Nset | undefined = inpData[\"assembly\"].nsets.find((nset: Nset) => {\n        return nset.setname == setName\n    });\n    if (!nset) {\n        throw new Error(\"Set not found\")\n    }\n\n    return nset.nodes\n}\n\n\nconst applyTemperatureBC = (K: Array<Array<number>>, inpData): Array<Array<number>> => {\n\n    inpData.steps[0].boundaries.temperature.forEach((temperature: TemperatureBC) => {\n        let setName = temperature.setName\n        let nset: Nset | undefined = inpData.assembly.nsets.find((nset: Nset) => {\n            return nset.setname == setName;\n        });\n        if (!nset) {\n            throw new Error(\"Nset not found\");\n        }\n\n        nset.nodes.forEach((node) => {\n            for (let i = 0; i < K.length; i++) {\n                K[node - 1][i] = 0\n            }\n            K[node - 1][node - 1] = 1\n        })\n    });\n\n\n    return K;\n}\n\nconst applyTemperatureBCToKTransitive = (K: Array<Array<number>>, inpData): Array<Array<number>> => {\n\n    inpData.steps[0].boundaries.temperature.forEach((temperature: TemperatureBC) => {\n        let setName = temperature.setName\n        let nset: Nset | undefined = inpData.assembly.nsets.find((nset: Nset) => {\n            return nset.setname == setName;\n        });\n        if (!nset) {\n            throw new Error(\"Nset not found\");\n        }\n\n        nset.nodes.forEach((node) => {\n            for (let i = 0; i < K.length; i++) {\n                if (i != node - 1) {\n                    K[node - 1][i] = 0\n                }\n            }\n        })\n    });\n\n    return K;\n}\n\nconst applyTemperatureBCToKTransitiveStep2 = (K: Array<Array<number>>, inpData): Array<Array<number>> => {\n\n    inpData.steps[0].boundaries.temperature.forEach((temperature: TemperatureBC) => {\n        let setName = temperature.setName\n        let nset: Nset | undefined = inpData.assembly.nsets.find((nset: Nset) => {\n            return nset.setname == setName;\n        });\n        if (!nset) {\n            throw new Error(\"Nset not found\");\n        }\n\n        nset.nodes.forEach((node) => {\n            for (let i = 0; i < K.length; i++) {\n                if (i != node - 1) {\n                    K[i][node - 1] = 0\n                }\n            }\n        })\n    });\n\n    return K;\n}\n\nconst getFForTransitive = (K: Array<Array<number>>, inpData, t: number = 0): number[] => {\n    let F: number[] = [];\n\n    for (let i = 0; i < K.length; i++) {\n        F.push(0);\n    }\n\n    inpData.steps[0].boundaries.temperature.forEach((temperature: TemperatureBCTransitive) => {\n        let setName = temperature.setName\n        let nset: Nset | undefined = inpData.assembly.nsets.find((nset: Nset) => {\n            return nset.setname == setName;\n        });\n        if (!nset) {\n            throw new Error(\"Nset not found\");\n        }\n\n\n        let temp = evaluateMathExpression(temperature.temperature.toString(), t);\n\n        nset.nodes.forEach((node) => {\n            F[node - 1] = K[node - 1][node - 1] * temp;\n        })\n    });\n\n    inpData.steps[0].boundaries.temperature.forEach((temperature: TemperatureBCTransitive) => {\n        let setName = temperature.setName\n        let nset: Nset | undefined = inpData.assembly.nsets.find((nset: Nset) => {\n            return nset.setname == setName;\n        });\n        if (!nset) {\n            throw new Error(\"Nset not found\");\n        }\n\n\n        let temp = evaluateMathExpression(temperature.temperature.toString(), t);\n\n        nset.nodes.forEach((node) => {\n            for (let i = 0; i < F.length; i++) {\n                if (i != node - 1) {\n                    F[i] -= K[i][node - 1] * temp;\n                }\n            }\n        })\n    });\n\n\n    return F;\n}\n\nconst getConductivityByElement = (element: number, blocks_termal_conductivity, lsets: Lset[], sections: Section[]): number => {\n\n    let lset = lsets.find((elset) => {\n        return elset.elements.indexOf(element) != -1;\n    })\n    if (!lset) {\n        throw new Error(\"Element not in elset\");\n    }\n    let lsetName: string = lset.setname;\n    let section = sections.find((section) => {\n        return section.elsetName == lsetName\n    })\n    if (!section) {\n        throw new Error(\"Elset not in section\");\n    }\n    let sectionName = section.name;\n\n    return blocks_termal_conductivity[sectionName] ?? 0;\n}\n\nconst getDensityByElement = (element: number, blocks_density, lsets: Lset[], sections: Section[]): number => {\n\n    let lset = lsets.find((elset) => {\n        return elset.elements.indexOf(element) != -1;\n    })\n    if (!lset) {\n        throw new Error(\"Element not in elset\");\n    }\n    let lsetName: string = lset.setname;\n    let section = sections.find((section) => {\n        return section.elsetName == lsetName\n    })\n    if (!section) {\n        throw new Error(\"Elset not in section\");\n    }\n    let sectionName = section.name;\n\n    return blocks_density[sectionName] ?? 0;\n}\n\nconst getCapacityByElement = (element: number, blocks_capacity, lsets: Lset[], sections: Section[]): number => {\n\n    let lset = lsets.find((elset) => {\n        return elset.elements.indexOf(element) != -1;\n    })\n    if (!lset) {\n        throw new Error(\"Element not in elset\");\n    }\n    let lsetName: string = lset.setname;\n    let section = sections.find((section) => {\n        return section.elsetName == lsetName\n    })\n    if (!section) {\n        throw new Error(\"Elset not in section\");\n    }\n    let sectionName = section.name;\n\n    return blocks_capacity[sectionName] ?? 0;\n}\n\n\nconst getConductivityMatrixTransitive = (inpData, blocks_termal_conductivity) => {\n    let nodes = inpData.problemData[0].nodes;\n    let elements = inpData.problemData[0].elements;\n\n    let K: number[][] = new Array(nodes.length);\n    for (let i = 0; i < K.length; i++) {\n        K[i] = new Array(nodes.length).fill(0);\n    }\n\n    for (let i = 0; i < elements.length; i++) {\n\n        let conductivity = getConductivityByElement(elements[i][0], blocks_termal_conductivity, inpData.problemData[0].lsets, inpData.problemData[0].sections);\n\n        let conductivityMatrix = [[conductivity, 0], [0, conductivity]]\n\n\n        let Xi = nodes[elements[i][1] - 1][1];\n        let Yi = nodes[elements[i][1] - 1][2];\n\n        let Xj = nodes[elements[i][2] - 1][1];\n        let Yj = nodes[elements[i][2] - 1][2];\n\n        let Xk = nodes[elements[i][3] - 1][1];\n        let Yk = nodes[elements[i][3] - 1][2];\n\n\n        let matrix: number[][] = [[1, Xi, Yi], [1, Xj, Yj], [1, Xk, Yk]]\n        let invMatrix: number[][] = InverseMatrix(matrix)\n        invMatrix.shift()\n\n        let Square = 0.5 * Math.abs(Xi * (Yj - Yk) + Xj * (Yk - Yi) + Xk * (Yi - Yj))\n\n        let K_local = multiplyMatrixByNumber(MultiplyMatrix(MultiplyMatrix(transposeMatrix(invMatrix), conductivityMatrix), invMatrix),Square)\n\n\n        K = accumulateToGlobalMatrix(K, K_local, elements[i][1], elements[i][2], elements[i][3]);\n\n    }\n\n\n    return K;\n\n}\n\nfunction hasAnyNan(array) {\n    for (let i = 0; i < array.length; i++) {\n      for (let j = 0; j < array[i].length; j++) {\n        if (isNaN(array[i][j])) {\n          return true;\n        }\n      }\n    }\n  \n    return false;\n  }\n  \n\nconst getConductivityMatrix = (inpData, blocks_termal_conductivity): Array<Array<number>> => {\n\n    let nodes = inpData.problemData[0].nodes;\n    let elements = inpData.problemData[0].elements;\n\n    let K: number[][] = new Array(nodes.length);\n    for (let i = 0; i < K.length; i++) {\n        K[i] = new Array(nodes.length).fill(0);\n    }\n\n    for (let i = 0; i < elements.length; i++) {\n\n        let conductivity = getConductivityByElement(elements[i][0], blocks_termal_conductivity, inpData.problemData[0].lsets, inpData.problemData[0].sections);\n        let R: number[][] = [[], [], []];\n        for (let j = 1; j <= 3; j++) {\n            R[j - 1] = [nodes[elements[i][j] - 1][1], nodes[elements[i][j] - 1][2]];\n        }\n\n        R = transposeMatrix(R);\n\n        let Ki = getLocalCondictivityMatrix(R, conductivity);\n        K = accumulateToGlobalMatrix(K, Ki, elements[i][1], elements[i][2], elements[i][3]);\n\n    }\n\n    return K;\n}\n\nconst getCapacityMatrix = (inpData, blocks_density, blocks_capacity): Array<Array<number>> => {\n\n    let nodes = inpData.problemData[0].nodes;\n    let elements = inpData.problemData[0].elements;\n\n    let C: number[][] = new Array(nodes.length);\n    for (let i = 0; i < C.length; i++) {\n        C[i] = new Array(nodes.length).fill(0);\n    }\n\n    for (let i = 0; i < elements.length; i++) {\n\n\n        let density = getDensityByElement(elements[i][0], blocks_density, inpData.problemData[0].lsets, inpData.problemData[0].sections);\n        let capacity = getCapacityByElement(elements[i][0], blocks_capacity, inpData.problemData[0].lsets, inpData.problemData[0].sections);\n        let coords: number[][] = [\n            [nodes[elements[i][1] - 1][1], nodes[elements[i][1] - 1][2]],\n            [nodes[elements[i][2] - 1][1], nodes[elements[i][2] - 1][2]],\n            [nodes[elements[i][3] - 1][1], nodes[elements[i][3] - 1][2]]\n\n        ]\n\n        let Ci = getLocalCapacityMatrix(coords, density, capacity);\n        C = accumulateToGlobalMatrix(C, Ci, elements[i][1], elements[i][2], elements[i][3]);\n\n    }\n\n    return C;\n}\n\nconst getLocalCondictivityMatrix = (coords: number[][], Lambda: number) => {\n\n    let J = [\n        [coords[0][2] - coords[0][0], coords[1][2] - coords[1][0]],\n        [coords[0][1] - coords[0][0], coords[1][1] - coords[1][0]]\n    ];\n\n    let Bnat = [\n        [-1, 0, 1],\n        [-1, 1, 0]\n    ];\n\n    let B = MultiplyMatrix(InverseMatrix(J), Bnat);\n    return MultiplyMatrix(multiplyMatrixByNumber(transposeMatrix(B), Lambda), multiplyMatrixByNumber(B, Determinant(J) / 2));\n}\n\nconst calculateTriangleArea = (coordinates: number[][]): number => {\n    const [point1, point2, point3] = coordinates;\n\n    const [x1, y1] = point1;\n    const [x2, y2] = point2;\n    const [x3, y3] = point3;\n\n    const area = 0.5 * Math.abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));\n\n    return area;\n}\n\nconst getLocalCapacityMatrix = (coords: number[][], density: number, capacity: number): number[][] => {\n\n    let Xi = coords[0][0];\n    let Yi = coords[0][1];\n\n    let Xj = coords[1][0];\n    let Yj = coords[1][1];\n\n    let Xk = coords[2][0];\n    let Yk = coords[2][1];\n\n    let square = 0.5 * Math.abs(Xi * (Yj - Yk) + Xj * (Yk - Yi) + Xk * (Yi - Yj))\n\n\n    return multiplyMatrixByNumber([\n        [2, 1, 1],\n        [1, 2, 1],\n        [1, 1, 2],\n    ], density * capacity / 12 * square)\n\n}\n\nconst accumulateToGlobalMatrix = (globalMatrix: Array<Array<number>>, localMatrix: Array<Array<number>>, i: number, j: number, k: number): Array<Array<number>> => {\n\n    i--\n    j--\n    k--\n\n    globalMatrix[i][i] += localMatrix[0][0]\n    globalMatrix[j][j] += localMatrix[1][1]\n    globalMatrix[k][k] += localMatrix[2][2]\n\n    globalMatrix[i][j] += localMatrix[0][1]\n    globalMatrix[j][i] += localMatrix[1][0]\n\n    globalMatrix[i][k] += localMatrix[0][2]\n    globalMatrix[k][i] += localMatrix[2][0]\n\n    globalMatrix[j][k] += localMatrix[1][2]\n    globalMatrix[k][j] += localMatrix[2][1]\n\n    return globalMatrix;\n}\n\nconst fixTemperatureFromBC = (temperature: number[], inpData, temperature_BC, t:number =0): number[] => {\n\n    for (let i = 0; i < temperature_BC.length; i++) {\n        let BC: TemperatureBCTransitive = temperature_BC[i];\n\n        let nodes: number[] = getNodesByAssemblySetName(BC.setName, inpData);\n\n        let temp = evaluateMathExpression(BC.temperature.toString(),t);\n\n        for (let i = 0; i < nodes.length; i++) {\n            let node: number = nodes[i];\n            temperature[node - 1] = temp;\n        }\n\n    }\n\n    return temperature\n}\n\nconst fixTemperatureFromBCBig = (temperature: Big[], inpData, temperature_BC): Big[] => {\n\n    for (let i = 0; i < temperature_BC.length; i++) {\n        let BC: TemperatureBC = temperature_BC[i];\n\n        let nodes: number[] = getNodesByAssemblySetName(BC.setName, inpData);\n\n        for (let i = 0; i < nodes.length; i++) {\n            let node: number = nodes[i];\n            temperature[node - 1] = new Big(BC.temperature);\n        }\n\n    }\n\n    return temperature\n}\n\n\nexport { computeSteadyState, computeTransitive }","import { computeSteadyState } from './computeHeatTransfer';\n\n\n// eslint-disable-next-line no-restricted-globals\nconst ctx: Worker = self as any;\n\nctx.addEventListener(\"message\", (event) => {\n\n    let inpData = event.data.inpData\n    let temperature_BC = event.data.temperature_BC\n    let blocks_termal_conductivity = event.data.blocks_termal_conductivity\n\n    let result: number[] = [];\n    try {\n        result = computeSteadyState(inpData, temperature_BC, blocks_termal_conductivity);\n    }\n    catch (e) {\n        postMessage({ action: \"error\", result: e });\n    }\n    postMessage({ action: \"done\", result: result });\n});\n\nexport default null as any;","import {parseCSV, interpolateMap} from \"./table\"\n\n\nconst evaluateMathExpression = (expression: string, t: number): number => {\n\n    const lines = expression.split(\"\\n\");\n\n    if(lines.length > 2 && lines[0].includes(\",\")){\n        const tableData = parseCSV(expression)        \n        const value = interpolateMap(tableData, t);\n\n        return value\n    }\n\n    expression = expression.replace(/t\\^(\\d+)/g, 'Math.pow(t, $1)');\n    expression = expression.replace(/sin/g, 'Math.sin');\n    expression = expression.replace(/cos/g, 'Math.cos');\n\n    const result: number = eval(expression);\n\n    \n    return result;\n}\n\nexport {evaluateMathExpression};","const parseCSV = (csvData: string) => {\n\n    const lines = csvData.split(\"\\n\");\n    const result: number[]= [];\n\n    for (let i = 0; i < lines.length; i++) {\n        const [time, temperature] = lines[i].split(\",\");\n        result[parseFloat(time)] = parseFloat(temperature);\n    }\n\n    return result;\n}\n\n\n\nfunction interpolateMap(map: number[], value: number): number {\n\n\n  const sortedKeys = Object.keys(map).sort((a: any, b: any) => a - b);\n  const firstValue = map[sortedKeys[0]];\n\n  if(value <= 0 || value <= parseFloat(sortedKeys[0]) ){\n    return firstValue;\n  }\n  \n  const keys = Object.keys(map).map((k) => parseFloat(k));\n  const lowerKey = keys.find((k) => k <= value);\n  const upperKey = keys.find((k) => k >= value);\n\n  if (lowerKey === undefined) {\n    return map[keys[0]];\n  } else if (upperKey === undefined) {\n    return map[keys[keys.length - 1]];\n  }\n\n  const lowerValue = map[lowerKey];\n  const upperValue = map[upperKey];\n  const weight = (value - lowerKey) / (upperKey - lowerKey);\n\n  return (1 - weight) * lowerValue + weight * upperValue;\n}\n\n\n\nexport {parseCSV, interpolateMap}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [51], () => (__webpack_require__(949)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"cf2901f9\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/heat-transfer/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t949: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkheat_transfer\"] = self[\"webpackChunkheat_transfer\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(51).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["transposeMatrix","matrix","transposedMatrix","i","length","j","push","MultiplyMatrix","A","B","rows1","cols1","cols2","Error","C","sum","k","multiplyMatrixByNumber","number","rows","cols","result","luDecomposition","n","lower","Array","upper","Determinant","det","cofactor","row","col","subMatrix","filter","_","r","map","c","computeSteadyState","inpData","temperature_BC","blocks_termal_conductivity","K","getConductivityMatrix","applyTemperatureBC","F","getTermalForcesFromBC","fixTemperatureFromBC","solveLinearEquationSystem","b","LU","y","x","problemData","nodes","BC","getNodesByAssemblySetName","setName","temperature","nset","nsets","find","setname","steps","boundaries","forEach","assembly","node","getConductivityByElement","element","lsets","sections","_blocks_termal_conduc","lset","elset","elements","indexOf","lsetName","section","elsetName","name","fill","conductivity","R","Ki","getLocalCondictivityMatrix","accumulateToGlobalMatrix","coords","Lambda","J","isSquareMatrix","calculateDeterminant","adjoint","transposed","cofactors","getSubmatrix","calculateCofactors","submatrix","InverseMatrix","globalMatrix","localMatrix","t","arguments","undefined","temp","evaluateMathExpression","toString","self","addEventListener","event","data","e","postMessage","action","expression","lines","split","includes","tableData","parseCSV","value","interpolateMap","replace","eval","csvData","time","parseFloat","sortedKeys","Object","keys","sort","a","firstValue","lowerKey","upperKey","lowerValue","upperValue","weight","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","id","loaded","__webpack_modules__","call","m","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","every","key","splice","d","definition","o","defineProperty","enumerable","get","f","chunkId","Promise","all","reduce","promises","u","miniCssF","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","nmd","paths","children","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}