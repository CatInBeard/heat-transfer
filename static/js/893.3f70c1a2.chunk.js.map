{"version":3,"file":"static/js/893.3f70c1a2.chunk.js","mappings":"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","sources":["matrix.tsx","computeHeatTransfer.tsx","computeTransitiveWorker.ts","mathExpression.ts","table.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["type LU = {\n    lower: number[][],\n    upper: number[][]\n}\n\nconst transposeMatrix = (matrix: number[][]): number[][] => {\n    let transposedMatrix: number[][] = [];\n\n    for (let i = 0; i < matrix[0].length; i++) {\n        transposedMatrix[i] = [];\n        for (let j = 0; j < matrix.length; j++) {\n            transposedMatrix[i].push(matrix[j][i]);\n        }\n    }\n\n    return transposedMatrix;\n}\n\nconst SumMatrix = (A: number[][], B: number[][]): number[][] => {\n\n    let C = new Array(A[0].length);\n\n    for (let i = 0; i < A.length; i++) {\n        C[i] = new Array(A[0].length);\n        for (let j = 0; j < A[0].length; j++) {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n\n    return C;\n}\n\nconst SumVector = (A: number[], B: number[]): number[] => {\n\n    let C = new Array(A.length);\n\n    for (let i = 0; i < A.length; i++) {\n        C[i] = A[i] + B[i];\n    }\n\n    return C;\n}\n\nconst MultiplyMatrix = (A: number[][], B: number[][]): number[][] => {\n    const rows1 = A.length;\n    const cols1 = A[0].length;\n    const cols2 = B[0].length;\n\n    if (cols1 !== B.length) {\n        throw new Error(\"The number of columns in the first matrix must match the number of rows in the second matrix.\");\n    }\n\n    const C: number[][] = [];\n\n    for (let i = 0; i < rows1; i++) {\n        C[i] = [];\n        for (let j = 0; j < cols2; j++) {\n            let sum = 0;\n            for (let k = 0; k < cols1; k++) {\n                sum += A[i][k] * B[k][j];\n            }\n            C[i][j] = sum;\n        }\n    }\n\n    return C;\n}\n\nconst MultiplyMatrixByVector = (A: number[][], v: number[]): number[] => {\n    const rows = A.length;\n    const cols = A[0].length;\n\n    if (cols !== v.length) {\n        throw new Error(\"The number of columns in the matrix must match the length of the vector.\");\n    }\n\n    const result: number[] = [];\n\n    for (let i = 0; i < rows; i++) {\n        let sum = 0;\n        for (let j = 0; j < cols; j++) {\n            sum += A[i][j] * v[j];\n        }\n        result[i] = sum;\n    }\n\n    return result;\n}\n\nconst multiplyMatrixByNumber = (matrix: number[][], number: number): number[][] => {\n    const rows = matrix.length;\n    const cols = matrix[0].length;\n\n    const result: number[][] = [];\n\n    for (let i = 0; i < rows; i++) {\n        result[i] = [];\n        for (let j = 0; j < cols; j++) {\n            result[i][j] = matrix[i][j] * number;\n        }\n    }\n\n    return result;\n}\n\nconst multiplyVectorByNumber = (matrix: number[], number: number): number[] => {\n\n    const result: number[] = [];\n\n    for (let i = 0; i < matrix.length; i++) {\n        result[i] = matrix[i] * number;\n    }\n\n    return result;\n}\n\nfunction InverseMatrix(matrix: number[][]): number[][] {\n    if (!isSquareMatrix(matrix)) {\n      throw new Error(\"Matrix must be square\");\n    }\n  \n    const det = calculateDeterminant(matrix);\n  \n    if (det === 0) {\n        throw new Error(\"Matrix has 0 det\");\n    }\n  \n    const cofactors = calculateCofactors(matrix);\n    const adjoint = transposeMatrix(cofactors);\n  \n    for (let i = 0; i < matrix.length; i++) {\n      for (let j = 0; j < matrix[i].length; j++) {\n        adjoint[i][j] /= det;\n      }\n    }\n\n    return adjoint;\n\n  \n    function isSquareMatrix(matrix: number[][]): boolean {\n      const n = matrix.length;\n      for (let i = 0; i < n; i++) {\n        if (matrix[i].length !== n) {\n          return false;\n        }\n      }\n      return true;\n    }\n  \n    function calculateDeterminant(matrix: number[][]): number {\n      if (matrix.length === 1) {\n        return matrix[0][0];\n      }\n  \n      let det = 0;\n      for (let i = 0; i < matrix.length; i++) {\n        det +=\n          matrix[0][i] *\n          calculateDeterminant(\n            getSubmatrix(matrix, 0, i)\n          ) *\n          ((-1) ** i);\n      }\n      return det;\n    }\n  \n    function calculateCofactors(matrix: number[][]): number[][] {\n      const cofactors: number[][] = [];\n      for (let i = 0; i < matrix.length; i++) {\n        cofactors[i] = [];\n        for (let j = 0; j < matrix[i].length; j++) {\n          cofactors[i][j] =\n            ((-1) ** (i + j)) *\n            calculateDeterminant(getSubmatrix(matrix, i, j));\n        }\n      }\n      return cofactors;\n    }\n  \n    function getSubmatrix(matrix: number[][], row: number, col: number): number[][] {\n      const submatrix: number[][] = [];\n      for (let i = 0; i < matrix.length; i++) {\n        if (i === row) continue;\n        submatrix.push(matrix[i].filter((_, c) => c != col));\n      }\n      return submatrix;\n    }\n  \n    function transposeMatrix(matrix: number[][]): number[][] {\n      const transposed: number[][] = [];\n      for (let i = 0; i < matrix[0].length; i++) {\n        transposed[i] = [];\n        for (let j = 0; j < matrix.length; j++) {\n          transposed[i][j] = matrix[j][i];\n        }\n      }\n      return transposed;\n    }\n  }\n  \n\n\nconst InverseMatrixLU = (A: number[][]) => { // LU inverse matrix\n    if (A.length != A[0].length) {\n        throw new Error(\"The matrix is not square\");\n    }\n\n    const n = A.length;\n    const identity = Array(n);\n    const inverse = Array(n);\n\n    for (let i = 0; i < n; i++) {\n        identity[i] = [];\n        inverse[i] = [];\n        for (let j = 0; j < n; j++) {\n            identity[i][j] = (i === j) ? 1 : 0;\n            inverse[i][j] = 0;\n        }\n    }\n\n    let LU = luDecomposition(A);\n\n    for (let k = 0; k < n; k++) {\n        const y = Array(n);\n        const b = Array(n);\n        for (let i = 0; i < n; i++) {\n            y[i] = 0;\n            b[i] = identity[i][k];\n            for (let j = 0; j < i; j++) {\n                y[i] += (LU.lower[i][j] * y[j]);\n            }\n            y[i] = (b[i] - y[i]) / LU.lower[i][i];\n        }\n        for (let i = n - 1; i >= 0; i--) {\n            inverse[i][k] = y[i];\n            for (let j = i + 1; j < n; j++) {\n                inverse[i][k] -= (LU.upper[i][j] * inverse[j][k]);\n            }\n            inverse[i][k] = inverse[i][k] / LU.upper[i][i];\n        }\n    }\n\n    return inverse;\n\n}\n\nconst luDecomposition = (matrix: number[][]): LU => {\n    const n = matrix.length;\n    const lower = Array(n);\n    const upper = Array(n);\n\n    for (let i = 0; i < n; i++) {\n        lower[i] = [];\n        upper[i] = [];\n        for (let j = 0; j < n; j++) {\n            lower[i][j] = 0;\n            upper[i][j] = 0;\n        }\n    }\n\n    for (let i = 0; i < n; i++) {\n        for (let k = i; k < n; k++) {\n            let sum = 0;\n            for (let j = 0; j < i; j++) {\n                sum += (lower[i][j] * upper[j][k]);\n            }\n            upper[i][k] = matrix[i][k] - sum;\n        }\n\n        for (let k = i; k < n; k++) {\n            if (i === k) {\n                lower[i][i] = 1;\n            } else {\n                let sum = 0;\n                for (let j = 0; j < i; j++) {\n                    sum += (lower[k][j] * upper[j][i]);\n                }\n                lower[k][i] = (matrix[k][i] - sum) / upper[i][i];\n            }\n        }\n    }\n\n    return { lower: lower, upper: upper };\n}\n\nconst solveLinearEquationSystem = (A: number[][], b: number[]): number[] => {\n    const LU = luDecomposition(A);\n    const n = A.length;\n    const y: number[] = [];\n    const x: number[] = [];\n\n    for (let i = 0; i < n; i++) {\n        let sum = 0;\n        for (let j = 0; j < i; j++) {\n            sum += LU.lower[i][j] * y[j];\n        }\n        y[i] = (b[i] - sum) / LU.lower[i][i];\n    }\n\n    for (let i = n - 1; i >= 0; i--) {\n        let sum = 0;\n        for (let j = i + 1; j < n; j++) {\n            sum += LU.upper[i][j] * x[j];\n        }\n        x[i] = (y[i] - sum) / LU.upper[i][i];\n    }\n\n    return x;\n}\n\nconst Determinant = (matrix: number[][]): number => {\n    if (matrix.length !== matrix[0].length) {\n        throw new Error(\"Matrix must be square\");\n    }\n\n    if (matrix.length === 1) {\n        return matrix[0][0];\n    }\n\n    if (matrix.length === 2) {\n        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];\n    }\n\n    let det = 0;\n\n    for (let i = 0; i < matrix.length; i++) {\n        det += matrix[0][i] * cofactor(matrix, 0, i);\n    }\n\n    return det;\n}\n\nconst cofactor = (matrix: number[][], row: number, col: number): number => {\n    const subMatrix = matrix.filter((_, r) => r !== row).map(row => row.filter((_, c) => c !== col));\n    const sign = (row + col) % 2 === 0 ? 1 : -1;\n    \n    return sign * Determinant(subMatrix);\n}\n\nconst frobeniusNorm = (matrix: number[][]): number => {\n    let sum = 0;\n    \n    for (let i = 0; i < matrix.length; i++) {\n        for (let j = 0; j < matrix[i].length; j++) {\n            sum += matrix[i][j] ** 2;\n        }\n    }\n    \n    return Math.sqrt(sum); \n}\n\n\n\nexport { transposeMatrix, SumMatrix, MultiplyMatrixByVector, multiplyVectorByNumber, SumVector, MultiplyMatrix, InverseMatrix, multiplyMatrixByNumber, solveLinearEquationSystem, Determinant, frobeniusNorm, InverseMatrixLU }","import { transposeMatrix, MultiplyMatrix, MultiplyMatrixByVector, SumVector, multiplyVectorByNumber, solveLinearEquationSystem, multiplyMatrixByNumber, InverseMatrix, Determinant, InverseMatrixLU, SumMatrix } from \"./matrix\";\nimport { Nset, Lset, Section, TemperatureBC, TemperatureBCTransitive } from \"./inpParse\"\nimport { evaluateMathExpression } from \"./mathExpression\"\nimport { cloneDeep } from 'lodash';\n\nconst calculateAverageBC = (\n    expression: string,\n    startTime: number,\n    endTime: number,\n    interval: number = 0.01\n): number => {\n    let sum = 0;\n    let count = 0;\n\n    for (let t = startTime; t <= endTime; t += interval) {\n        const value = evaluateMathExpression(expression.toString(), t);\n        sum += value;\n        count++;\n    }\n\n    return sum / count;\n};\n\n\nconst computeTransitive = (inpData, temperature_BC, blocks_termal_conductivity, blocks_density, blocks_capacity, progress_callback, initialTemp = 0, timeStep = 0.1, steps = 500, method = \"forward\", initialTempArray = null) => {\n\n\n    let freq = 1 / timeStep;\n\n    let K: number[][] = getConductivityMatrixTransitive(inpData, blocks_termal_conductivity);\n\n    let C: number[][] = getCapacityMatrix(inpData, blocks_density, blocks_capacity);\n\n    let KForF = applyTemperatureBCToKTransitive(K, inpData);\n\n\n    let F: number[] = getFForTransitive(KForF, inpData);\n\n    K = cloneDeep(KForF)\n\n    K = applyTemperatureBCToKTransitiveStep2(K, inpData);\n\n\n    if (progress_callback === null) {\n        progress_callback = (progress, data) => {\n            console.log(\"progress: \" + progress + \"%\")\n        }\n    }\n\n    let temperaturePrevStep: number[] = [];\n    let temperatureCurrentStep: number[] = [];\n\n    if (initialTempArray === null) {\n        for (let i = 0; i < F.length; i++) {\n            temperaturePrevStep.push(initialTemp);\n        }\n    }\n    else {\n        temperaturePrevStep = initialTempArray;\n    }\n    temperaturePrevStep = fixTemperatureFromBC(temperaturePrevStep, inpData, temperature_BC)\n\n    let temperatureFrames: number[][] = [];\n\n    temperatureFrames.push(temperaturePrevStep);\n\n\n    switch (method) {\n        case \"crank-nicolson\":\n            cracnNicolsonSolve(steps, KForF, inpData, C, freq, K, temperaturePrevStep, F, temperatureCurrentStep, temperature_BC, temperatureFrames, progress_callback, timeStep);\n            break;\n        default:\n            forwardEulerTransitiveSolve(steps, KForF, inpData, C, freq, K, temperaturePrevStep, F, temperatureCurrentStep, temperature_BC, temperatureFrames, progress_callback, timeStep);\n    }\n\n    return temperatureFrames;\n\n}\n\nconst forwardEulerTransitiveSolve = (steps, KForF, inpData, C, freq, K, temperaturePrevStep, F, temperatureCurrentStep, temperature_BC, temperatureFrames, progress_callback, timeStep) => {\n\n    let progress = 0;\n\n    let realTime = 0;\n\n    for (let t = 0; t < steps; t++) {\n\n        F = getFForTransitive(KForF, inpData, realTime);\n\n        let A = multiplyMatrixByNumber(C, freq)\n        let b = SumVector(\n            SumVector(F, multiplyVectorByNumber(\n                MultiplyMatrixByVector(K, temperaturePrevStep), -1)),\n            multiplyVectorByNumber(\n                MultiplyMatrixByVector(C, temperaturePrevStep), freq))\n        let Temperature = solveLinearEquationSystem(A, b)\n\n        temperatureCurrentStep = fixTemperatureFromBC(Temperature, inpData, temperature_BC, realTime)\n\n        temperatureCurrentStep = Temperature\n\n        temperatureFrames.push(temperatureCurrentStep);\n        temperaturePrevStep = temperatureCurrentStep;\n\n        progress += 100 / steps\n        progress_callback(progress, temperatureCurrentStep)\n        realTime += timeStep\n    }\n\n}\n\nconst cracnNicolsonSolve = (steps, KForF, inpData, C, freq, K, temperaturePrevStep, F, temperatureCurrentStep, temperature_BC, temperatureFrames, progress_callback, timeStep) => {\n\n    let progress = 0;\n\n    let realTime = 0;\n\n    let FPrev = cloneDeep(F)\n\n    for (let t = 0; t < steps; t++) {\n\n        F = getFForTransitive(KForF, inpData, realTime);\n\n        let A = SumMatrix(C, multiplyMatrixByNumber(K, timeStep / 2));\n        let b = SumVector(\n            MultiplyMatrixByVector(\n                SumMatrix(\n                    C,\n                    multiplyMatrixByNumber(\n                        K,\n                        -1 * timeStep / 2\n                    )\n                ),\n                temperaturePrevStep\n            ),\n            multiplyVectorByNumber(\n                SumVector(FPrev, F),\n                timeStep / 2\n            )\n        )\n\n        let Temperature = solveLinearEquationSystem(A, b)\n\n        temperatureCurrentStep = fixTemperatureFromBC(Temperature, inpData, temperature_BC, realTime)\n\n        temperatureCurrentStep = Temperature\n\n        temperatureFrames.push(temperatureCurrentStep);\n        temperaturePrevStep = temperatureCurrentStep;\n\n        progress += 100 / steps\n        progress_callback(progress, temperatureCurrentStep)\n        realTime += timeStep\n        FPrev = cloneDeep(F)\n    }\n\n}\n\n\nconst computeSteadyState = (inpData, temperature_BC, blocks_termal_conductivity) => {\n\n    let K = getConductivityMatrix(inpData, blocks_termal_conductivity);\n\n    K = applyTemperatureBC(K, inpData);\n\n    let F = getTermalForcesFromBC(inpData, temperature_BC);\n\n    let temperatures = fixTemperatureFromBC(solveLinearEquationSystem(K, F), inpData, temperature_BC);\n\n    return temperatures\n\n}\n\n\nconst getTermalForcesFromBC = (inpData, temperature_BC): number[] => {\n    let length = inpData.problemData[0].nodes.length;\n\n    let F: number[] = Array(length);\n    for (let i = 0; i < length; i++) {\n        F[i] = 0;\n    }\n\n    for (let i = 0; i < temperature_BC.length; i++) {\n        let BC: TemperatureBC = temperature_BC[i];\n\n        let nodes: number[] = getNodesByAssemblySetName(BC.setName, inpData);\n\n        for (let i = 0; i < nodes.length; i++) {\n            let node: number = nodes[i];\n            F[node - 1] = BC.temperature;\n        }\n\n    }\n\n    return F;\n}\n\nconst getNodesByAssemblySetName = (setName: string, inpData): number[] => {\n\n    let nset: Nset | undefined = inpData[\"assembly\"].nsets.find((nset: Nset) => {\n        return nset.setname == setName\n    });\n    if (!nset) {\n        throw new Error(\"Set not found\")\n    }\n\n    return nset.nodes\n}\n\n\nconst applyTemperatureBC = (K: Array<Array<number>>, inpData): Array<Array<number>> => {\n\n    inpData.steps[0].boundaries.temperature.forEach((temperature: TemperatureBC) => {\n        let setName = temperature.setName\n        let nset: Nset | undefined = inpData.assembly.nsets.find((nset: Nset) => {\n            return nset.setname == setName;\n        });\n        if (!nset) {\n            throw new Error(\"Nset not found\");\n        }\n\n        nset.nodes.forEach((node) => {\n            for (let i = 0; i < K.length; i++) {\n                K[node - 1][i] = 0\n            }\n            K[node - 1][node - 1] = 1\n        })\n    });\n\n\n    return K;\n}\n\nconst applyTemperatureBCToKTransitive = (K: Array<Array<number>>, inpData): Array<Array<number>> => {\n\n    inpData.steps[0].boundaries.temperature.forEach((temperature: TemperatureBC) => {\n        let setName = temperature.setName\n        let nset: Nset | undefined = inpData.assembly.nsets.find((nset: Nset) => {\n            return nset.setname == setName;\n        });\n        if (!nset) {\n            throw new Error(\"Nset not found\");\n        }\n\n        nset.nodes.forEach((node) => {\n            for (let i = 0; i < K.length; i++) {\n                if (i != node - 1) {\n                    K[node - 1][i] = 0\n                }\n            }\n        })\n    });\n\n    return K;\n}\n\nconst applyTemperatureBCToKTransitiveStep2 = (K: Array<Array<number>>, inpData): Array<Array<number>> => {\n\n    inpData.steps[0].boundaries.temperature.forEach((temperature: TemperatureBC) => {\n        let setName = temperature.setName\n        let nset: Nset | undefined = inpData.assembly.nsets.find((nset: Nset) => {\n            return nset.setname == setName;\n        });\n        if (!nset) {\n            throw new Error(\"Nset not found\");\n        }\n\n        nset.nodes.forEach((node) => {\n            for (let i = 0; i < K.length; i++) {\n                if (i != node - 1) {\n                    K[i][node - 1] = 0\n                }\n            }\n        })\n    });\n\n    return K;\n}\n\nconst getFForTransitive = (K: Array<Array<number>>, inpData, t: number = 0): number[] => {\n    let F: number[] = [];\n\n    for (let i = 0; i < K.length; i++) {\n        F.push(0);\n    }\n\n    inpData.steps[0].boundaries.temperature.forEach((temperature: TemperatureBCTransitive) => {\n        let setName = temperature.setName\n        let nset: Nset | undefined = inpData.assembly.nsets.find((nset: Nset) => {\n            return nset.setname == setName;\n        });\n        if (!nset) {\n            throw new Error(\"Nset not found\");\n        }\n\n\n        let temp = evaluateMathExpression(temperature.temperature.toString(), t);\n\n        nset.nodes.forEach((node) => {\n            F[node - 1] = K[node - 1][node - 1] * temp;\n        })\n    });\n\n    inpData.steps[0].boundaries.temperature.forEach((temperature: TemperatureBCTransitive) => {\n        let setName = temperature.setName\n        let nset: Nset | undefined = inpData.assembly.nsets.find((nset: Nset) => {\n            return nset.setname == setName;\n        });\n        if (!nset) {\n            throw new Error(\"Nset not found\");\n        }\n\n\n        let temp = evaluateMathExpression(temperature.temperature.toString(), t);\n\n        nset.nodes.forEach((node) => {\n            for (let i = 0; i < F.length; i++) {\n                if (i != node - 1) {\n                    F[i] -= K[i][node - 1] * temp;\n                }\n            }\n        })\n    });\n\n\n    return F;\n}\n\nconst getConductivityByElement = (element: number, blocks_termal_conductivity, lsets: Lset[], sections: Section[]): number => {\n\n    let lset = lsets.find((elset) => {\n        return elset.elements.indexOf(element) != -1;\n    })\n    if (!lset) {\n        throw new Error(\"Element not in elset\");\n    }\n    let lsetName: string = lset.setname;\n    let section = sections.find((section) => {\n        return section.elsetName == lsetName\n    })\n    if (!section) {\n        throw new Error(\"Elset not in section\");\n    }\n    let sectionName = section.name;\n\n    return blocks_termal_conductivity[sectionName] ?? 0;\n}\n\nconst getDensityByElement = (element: number, blocks_density, lsets: Lset[], sections: Section[]): number => {\n\n    let lset = lsets.find((elset) => {\n        return elset.elements.indexOf(element) != -1;\n    })\n    if (!lset) {\n        throw new Error(\"Element not in elset\");\n    }\n    let lsetName: string = lset.setname;\n    let section = sections.find((section) => {\n        return section.elsetName == lsetName\n    })\n    if (!section) {\n        throw new Error(\"Elset not in section\");\n    }\n    let sectionName = section.name;\n\n    return blocks_density[sectionName] ?? 0;\n}\n\nconst getCapacityByElement = (element: number, blocks_capacity, lsets: Lset[], sections: Section[]): number => {\n\n    let lset = lsets.find((elset) => {\n        return elset.elements.indexOf(element) != -1;\n    })\n    if (!lset) {\n        throw new Error(\"Element not in elset\");\n    }\n    let lsetName: string = lset.setname;\n    let section = sections.find((section) => {\n        return section.elsetName == lsetName\n    })\n    if (!section) {\n        throw new Error(\"Elset not in section\");\n    }\n    let sectionName = section.name;\n\n    return blocks_capacity[sectionName] ?? 0;\n}\n\n\nconst getConductivityMatrixTransitive = (inpData, blocks_termal_conductivity) => {\n    let nodes = inpData.problemData[0].nodes;\n    let elements = inpData.problemData[0].elements;\n\n    let K: number[][] = new Array(nodes.length);\n    for (let i = 0; i < K.length; i++) {\n        K[i] = new Array(nodes.length).fill(0);\n    }\n\n    for (let i = 0; i < elements.length; i++) {\n\n        let conductivity = getConductivityByElement(elements[i][0], blocks_termal_conductivity, inpData.problemData[0].lsets, inpData.problemData[0].sections);\n\n        let conductivityMatrix = [[conductivity, 0], [0, conductivity]]\n\n\n        let Xi = nodes[elements[i][1] - 1][1];\n        let Yi = nodes[elements[i][1] - 1][2];\n\n        let Xj = nodes[elements[i][2] - 1][1];\n        let Yj = nodes[elements[i][2] - 1][2];\n\n        let Xk = nodes[elements[i][3] - 1][1];\n        let Yk = nodes[elements[i][3] - 1][2];\n\n\n        let matrix: number[][] = [[1, Xi, Yi], [1, Xj, Yj], [1, Xk, Yk]]\n        let invMatrix: number[][] = InverseMatrix(matrix)\n        invMatrix.shift()\n\n        let Square = 0.5 * Math.abs(Xi * (Yj - Yk) + Xj * (Yk - Yi) + Xk * (Yi - Yj))\n\n        let K_local = multiplyMatrixByNumber(MultiplyMatrix(MultiplyMatrix(transposeMatrix(invMatrix), conductivityMatrix), invMatrix), Square)\n\n\n        K = accumulateToGlobalMatrix(K, K_local, elements[i][1], elements[i][2], elements[i][3]);\n\n    }\n\n\n    return K;\n\n}\n\nfunction hasAnyNan(array) {\n    for (let i = 0; i < array.length; i++) {\n        for (let j = 0; j < array[i].length; j++) {\n            if (isNaN(array[i][j])) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n\nconst getConductivityMatrix = (inpData, blocks_termal_conductivity): Array<Array<number>> => {\n\n    let nodes = inpData.problemData[0].nodes;\n    let elements = inpData.problemData[0].elements;\n\n    let K: number[][] = new Array(nodes.length);\n    for (let i = 0; i < K.length; i++) {\n        K[i] = new Array(nodes.length).fill(0);\n    }\n\n    for (let i = 0; i < elements.length; i++) {\n\n        let conductivity = getConductivityByElement(elements[i][0], blocks_termal_conductivity, inpData.problemData[0].lsets, inpData.problemData[0].sections);\n        let R: number[][] = [[], [], []];\n        for (let j = 1; j <= 3; j++) {\n            R[j - 1] = [nodes[elements[i][j] - 1][1], nodes[elements[i][j] - 1][2]];\n        }\n\n        R = transposeMatrix(R);\n\n        let Ki = getLocalCondictivityMatrix(R, conductivity);\n        K = accumulateToGlobalMatrix(K, Ki, elements[i][1], elements[i][2], elements[i][3]);\n\n    }\n\n    return K;\n}\n\nconst getCapacityMatrix = (inpData, blocks_density, blocks_capacity): Array<Array<number>> => {\n\n    let nodes = inpData.problemData[0].nodes;\n    let elements = inpData.problemData[0].elements;\n\n    let C: number[][] = new Array(nodes.length);\n    for (let i = 0; i < C.length; i++) {\n        C[i] = new Array(nodes.length).fill(0);\n    }\n\n    for (let i = 0; i < elements.length; i++) {\n\n\n        let density = getDensityByElement(elements[i][0], blocks_density, inpData.problemData[0].lsets, inpData.problemData[0].sections);\n        let capacity = getCapacityByElement(elements[i][0], blocks_capacity, inpData.problemData[0].lsets, inpData.problemData[0].sections);\n        let coords: number[][] = [\n            [nodes[elements[i][1] - 1][1], nodes[elements[i][1] - 1][2]],\n            [nodes[elements[i][2] - 1][1], nodes[elements[i][2] - 1][2]],\n            [nodes[elements[i][3] - 1][1], nodes[elements[i][3] - 1][2]]\n\n        ]\n\n        let Ci = getLocalCapacityMatrix(coords, density, capacity);\n        C = accumulateToGlobalMatrix(C, Ci, elements[i][1], elements[i][2], elements[i][3]);\n\n    }\n\n    return C;\n}\n\nconst getLocalCondictivityMatrix = (coords: number[][], Lambda: number) => {\n\n    let J = [\n        [coords[0][2] - coords[0][0], coords[1][2] - coords[1][0]],\n        [coords[0][1] - coords[0][0], coords[1][1] - coords[1][0]]\n    ];\n\n    let Bnat = [\n        [-1, 0, 1],\n        [-1, 1, 0]\n    ];\n\n    let B = MultiplyMatrix(InverseMatrix(J), Bnat);\n    return MultiplyMatrix(multiplyMatrixByNumber(transposeMatrix(B), Lambda), multiplyMatrixByNumber(B, Determinant(J) / 2));\n}\n\nconst calculateTriangleArea = (coordinates: number[][]): number => {\n    const [point1, point2, point3] = coordinates;\n\n    const [x1, y1] = point1;\n    const [x2, y2] = point2;\n    const [x3, y3] = point3;\n\n    const area = 0.5 * Math.abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));\n\n    return area;\n}\n\nconst getLocalCapacityMatrix = (coords: number[][], density: number, capacity: number): number[][] => {\n\n    let Xi = coords[0][0];\n    let Yi = coords[0][1];\n\n    let Xj = coords[1][0];\n    let Yj = coords[1][1];\n\n    let Xk = coords[2][0];\n    let Yk = coords[2][1];\n\n    let square = 0.5 * Math.abs(Xi * (Yj - Yk) + Xj * (Yk - Yi) + Xk * (Yi - Yj))\n\n\n    return multiplyMatrixByNumber([\n        [2, 1, 1],\n        [1, 2, 1],\n        [1, 1, 2],\n    ], density * capacity / 12 * square)\n\n}\n\nconst accumulateToGlobalMatrix = (globalMatrix: Array<Array<number>>, localMatrix: Array<Array<number>>, i: number, j: number, k: number): Array<Array<number>> => {\n\n    i--\n    j--\n    k--\n\n    globalMatrix[i][i] += localMatrix[0][0]\n    globalMatrix[j][j] += localMatrix[1][1]\n    globalMatrix[k][k] += localMatrix[2][2]\n\n    globalMatrix[i][j] += localMatrix[0][1]\n    globalMatrix[j][i] += localMatrix[1][0]\n\n    globalMatrix[i][k] += localMatrix[0][2]\n    globalMatrix[k][i] += localMatrix[2][0]\n\n    globalMatrix[j][k] += localMatrix[1][2]\n    globalMatrix[k][j] += localMatrix[2][1]\n\n    return globalMatrix;\n}\n\nconst fixTemperatureFromBC = (temperature: number[], inpData, temperature_BC, t: number = 0): number[] => {\n\n    for (let i = 0; i < temperature_BC.length; i++) {\n        let BC: TemperatureBCTransitive = temperature_BC[i];\n\n        let nodes: number[] = getNodesByAssemblySetName(BC.setName, inpData);\n\n        let temp = evaluateMathExpression(BC.temperature.toString(), t);\n\n        for (let i = 0; i < nodes.length; i++) {\n            let node: number = nodes[i];\n            temperature[node - 1] = temp;\n        }\n\n    }\n\n    return temperature\n}\n\n\nexport { computeSteadyState, computeTransitive, calculateAverageBC }","import { computeTransitive, calculateAverageBC } from \"./computeHeatTransfer\"\nimport { cloneDeep } from 'lodash';\n\n\n// eslint-disable-next-line no-restricted-globals\nconst ctx: Worker = self as any;\n\nctx.addEventListener(\"message\", (event) => {\n\n    let inpData = event.data.inpData\n    let temperature_BC = event.data.temperature_BC\n    let blocks_termal_conductivity = event.data.blocks_termal_conductivity\n    let blocks_density = event.data.blocks_density\n    let blocks_specific_heat = event.data.blocks_specific_heat\n    let initialTemp = event.data.initialTemp\n    let stepIncrement = event.data.stepIncrement\n    let steps = event.data.steps\n    let method = event.data.method\n\n    let usePreStep = event.data.usePreStep\n\n    let result: number[][] = [];\n\n    if (usePreStep) {\n\n        let preStepResult: number[][] = [];\n\n        let useAverageTemp = event.data.usePreStep\n        let preStepSteps = event.data.preStepSteps\n        let preStepIncrement = event.data.preStepIncrement\n\n        let preStepBC = []\n        \n\n        if(useAverageTemp){\n            preStepBC = temperature_BC.map( (BC) => {\n                let averageBC = cloneDeep(BC)\n                averageBC.temperature = calculateAverageBC(averageBC.temperature, 0, preStepSteps * preStepIncrement , 10)\n                return averageBC\n            })\n        }\n        else{\n            preStepBC = event.data.preStepBC\n        }\n\n        try {\n            preStepResult = computeTransitive(inpData, preStepBC, blocks_termal_conductivity, blocks_density, blocks_specific_heat, progress_callback_preStep, initialTemp, preStepIncrement, preStepSteps, \"crank-nicolson\");\n            result = computeTransitive(inpData, temperature_BC, blocks_termal_conductivity, blocks_density, blocks_specific_heat, callback, initialTemp, stepIncrement, steps, method, preStepResult[preStepResult.length-1]);\n        }\n        catch (e) {\n            postMessage({ action: \"error\", result: e });\n        }\n    }\n    else {\n        try {\n            result = computeTransitive(inpData, temperature_BC, blocks_termal_conductivity, blocks_density, blocks_specific_heat, callback, initialTemp, stepIncrement, steps, method);\n        }\n        catch (e) {\n            postMessage({ action: \"error\", result: e });\n        }\n    }\n    postMessage({ action: \"done\", result: result });\n});\n\n\nconst callback = (progress, data) => {\n    postMessage({ action: \"progress\", result: progress, temp: data });\n}\n\nconst progress_callback_preStep = (progress, data) => {\n    postMessage({ action: \"progress_preStep\", result: progress, temp: data });\n}\n\nexport default null as any;","import {parseCSV, interpolateMap} from \"./table\"\n\n\nconst evaluateMathExpression = (expression: string, t: number): number => {\n\n    const lines = expression.split(\"\\n\");\n\n    if(lines.length > 2 && lines[0].includes(\",\")){\n        const tableData = parseCSV(expression)        \n        const value = interpolateMap(tableData, t);\n\n        return value\n    }\n\n    expression = expression.replace(/t\\^(\\d+)/g, 'Math.pow(t, $1)');\n    expression = expression.replace(/sin/g, 'Math.sin');\n    expression = expression.replace(/cos/g, 'Math.cos');\n\n    const result: number = eval(expression);\n\n    \n    return result;\n}\n\nexport {evaluateMathExpression};","const parseCSV = (csvData: string) => {\n\n    const lines = csvData.split(\"\\n\");\n    const result: number[]= [];\n\n    for (let i = 0; i < lines.length; i++) {\n        const [time, temperature] = lines[i].split(\",\");\n        result[parseFloat(time)] = parseFloat(temperature);\n    }\n\n    return result;\n}\n\n\n\nfunction interpolateMap(map: number[], value: number): number {\n\n\n  const sortedKeys = Object.keys(map).sort((a: any, b: any) => a - b);\n  const firstValue = map[sortedKeys[0]];\n\n  if(value <= 0 || value <= parseFloat(sortedKeys[0]) ){\n    return firstValue;\n  }\n  \n  const keys = Object.keys(map).map((k) => parseFloat(k));\n  const lowerKey = keys.find((k) => k <= value);\n  const upperKey = keys.find((k) => k >= value);\n\n  if (lowerKey === undefined) {\n    return map[keys[0]];\n  } else if (upperKey === undefined) {\n    return map[keys[keys.length - 1]];\n  }\n\n  const lowerValue = map[lowerKey];\n  const upperValue = map[upperKey];\n  const weight = (value - lowerKey) / (upperKey - lowerKey);\n\n  return (1 - weight) * lowerValue + weight * upperValue;\n}\n\n\n\nexport {parseCSV, interpolateMap}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [536], () => (__webpack_require__(893)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"c57e7181\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/heat-transfer/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t893: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkheat_transfer\"] = self[\"webpackChunkheat_transfer\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(536).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["transposeMatrix","matrix","transposedMatrix","i","length","j","push","SumMatrix","A","B","C","Array","SumVector","MultiplyMatrix","rows1","cols1","cols2","Error","sum","k","MultiplyMatrixByVector","v","rows","cols","result","multiplyMatrixByNumber","number","multiplyVectorByNumber","InverseMatrix","n","isSquareMatrix","det","calculateDeterminant","cofactors","getSubmatrix","calculateCofactors","adjoint","transposed","row","col","submatrix","filter","_","c","luDecomposition","lower","upper","solveLinearEquationSystem","b","LU","y","x","computeTransitive","inpData","temperature_BC","blocks_termal_conductivity","blocks_density","blocks_capacity","progress_callback","initialTemp","arguments","undefined","timeStep","steps","method","initialTempArray","freq","K","getConductivityMatrixTransitive","getCapacityMatrix","KForF","applyTemperatureBCToKTransitive","F","getFForTransitive","cloneDeep","applyTemperatureBCToKTransitiveStep2","progress","data","console","log","temperaturePrevStep","temperatureCurrentStep","fixTemperatureFromBC","temperatureFrames","cracnNicolsonSolve","forwardEulerTransitiveSolve","realTime","t","Temperature","FPrev","getNodesByAssemblySetName","setName","nset","nsets","find","setname","nodes","boundaries","temperature","forEach","assembly","node","temp","evaluateMathExpression","toString","getConductivityByElement","element","lsets","sections","_blocks_termal_conduc","lset","elset","elements","indexOf","lsetName","section","elsetName","name","getDensityByElement","_blocks_density$secti","getCapacityByElement","_blocks_capacity$sect","problemData","fill","conductivity","conductivityMatrix","Xi","Yi","Xj","Yj","Xk","Yk","invMatrix","shift","Square","Math","abs","K_local","accumulateToGlobalMatrix","density","capacity","coords","Ci","getLocalCapacityMatrix","square","globalMatrix","localMatrix","BC","self","addEventListener","event","blocks_specific_heat","stepIncrement","usePreStep","preStepResult","useAverageTemp","preStepSteps","preStepIncrement","preStepBC","map","averageBC","expression","startTime","endTime","interval","count","calculateAverageBC","progress_callback_preStep","callback","e","postMessage","action","lines","split","includes","tableData","parseCSV","value","interpolateMap","replace","eval","csvData","time","parseFloat","sortedKeys","Object","keys","sort","a","firstValue","lowerKey","upperKey","lowerValue","upperValue","weight","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","id","loaded","__webpack_modules__","call","m","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","every","key","splice","r","d","definition","o","defineProperty","enumerable","get","f","chunkId","Promise","all","reduce","promises","u","miniCssF","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","nmd","paths","children","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}